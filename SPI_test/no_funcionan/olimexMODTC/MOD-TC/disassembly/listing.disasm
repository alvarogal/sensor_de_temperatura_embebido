Disassembly Listing for MOD-TC
Generated From:

---  E:/Local Repository/MOD-TC/Software/trunk/WEB_files/Demo_Example_WEB_files/PIC-P26J50 + MOD-TC-MK2/MOD-TC/user.c
1:             /******************************************************************************/
2:             /* Files to Include                                                           */
3:             /******************************************************************************/
4:             
5:             #include <htc.h>            /* HiTech General Includes */
6:             #include <stdint.h>         /* For uint8_t definition */
7:             #include <stdbool.h>        /* For true/false definition */
8:             
9:             #include "user.h"
10:            #include "i2c.h"
11:            #include "OLIMEX.h"
12:            #include "MAX31855.h"
13:            
14:            /******************************************************************************/
15:            /* User Functions                                                             */
16:            /******************************************************************************/
17:            
18:            /* <Initialize variables in user.h and insert code for user algorithms.> */
19:            
20:            void InitApp(void)
21:            {
22:            
23:            	
24:                /* Setup analog functionality and port direction */
25:            	ANSELC = 0x00;
031A  0023     MOVLB 0x3
26:            	ANSELA = 0x00;
031C  018C     CLRF PORTA
27:            
28:            	SCL_TRIS = 1;
031D  0021     MOVLB 0x1
031E  160E     BSF PORTC, 0x4
29:            	SDA_TRIS = 1;
031F  168E     BSF PORTC, 0x5
30:            	SCL_LAT = 0;
0320  0022     MOVLB 0x2
0321  120E     BCF PORTC, 0x4
31:            	SDA_LAT = 0;
0322  128E     BCF PORTC, 0x5
32:            
33:            	InitSPI();
0323  2368     CALL 0x368
34:            
35:            	OPTION_REGbits.nWPUEN = 0;
0324  0021     MOVLB 0x1
0325  1395     BCF TMR0, 0x7
36:            	WPUAbits.WPUA = 0;
0326  30C0     MOVLW 0xC0
0327  0024     MOVLB 0x4
0328  058C     ANDWF PORTA, F
37:            	WPUAbits.WPUA5 = 1;
0329  168C     BSF PORTA, 0x5
38:            	JMP_TRIS = 1;
032A  0021     MOVLB 0x1
032B  168C     BSF PORTA, 0x5
39:            	JMP_LAT = 0;
032C  0022     MOVLB 0x2
032D  128C     BCF PORTA, 0x5
40:            	
41:            
42:            
43:            
44:                /* Initialize peripherals */
45:            
46:                /* Enable interrupts */
47:            }
032E  0008     RETURN
48:            void InitAddress(void)
49:            {
50:            	char address;
51:            	/* READ THE JUMPER*/
52:            	JMP_TRIS = 1;
53:            	WPUAbits.WPUA5 = 1;
54:            	if(!JMP_PORT)
55:            	{
56:            		/* SET ADDRESS FOR PROGRAMMING*/
57:            		ADDRESS = 0xF0;
58:            		return;
59:            	}
60:            	else
61:            	{
62:            		address = ReadFlash(ADDR_MEM);
63:            		/* IF THE MEMORY CELL IS EMPTY*/
64:            		if (address == 0xFF)
65:            		{
66:            			ADDRESS = ADDR_DFL;
67:            		}
68:            		else
69:            		{
70:            			ADDRESS = address;
71:            		}
72:            	}
73:            	
74:            }
75:            char ReadFlash(short address)
76:            {
77:            	char data = 0;
78:            	PMADRL = address & 0x00FF;
79:            	address >>= 8;
80:            	PMADRH = address & 0x00FF;
81:            	PMCON1bits.CFGS = 0;
82:            	PMCON1bits.RD = 1;
83:            	Nop();
84:            	Nop();
85:            
86:            	data = PMDATL;
87:            	return data;
88:            }
89:            void EraseFlash(short address)
90:            {
91:            	GIE = 0;
032F  138B     BCF INTCON, 0x7
92:            	PMADRL = address & 0x00FF;
0330  0870     MOVF i, W
0331  0023     MOVLB 0x3
0332  0091     MOVWF PIR1
93:            	address >>= 8;
0333  0871     MOVF i, W
0334  00F0     MOVWF i
0335  01F1     CLRF i
0336  1BF0     BTFSC i, 0x7
0337  03F1     DECF i, F
94:            	PMADRH = address & 0x00FF;
0338  0092     MOVWF PIR2
95:            	PMCON1bits.CFGS = 0;
0339  1315     BCF TMR0, 0x6
96:            	PMCON1bits.FREE = 1;
033A  1615     BSF TMR0, 0x4
97:            	PMCON1bits.WREN = 1;
033B  1515     BSF TMR0, 0x2
98:            	UnlockFlash();
033C  2370     CALL 0x370
99:            	PMCON1bits.WREN = 0;
033D  0023     MOVLB 0x3
033E  1115     BCF TMR0, 0x2
100:           	GIE = 1;
033F  178B     BSF INTCON, 0x7
101:           }
0340  0008     RETURN
102:           void UnlockFlash(void)
103:           {
104:           	PMCON2 = 0x55;
0370  3055     MOVLW 0x55
0371  0096     MOVWF TMR1L
105:           	PMCON2 = 0xAA;
0372  30AA     MOVLW 0xAA
0373  0096     MOVWF TMR1L
106:           	PMCON1bits.WR = 1;
0374  1495     BSF TMR0, 0x1
107:           	Nop();
0375  0000     NOP
108:           	Nop();
0376  0000     NOP
109:           }
0377  0008     RETURN
110:           void WriteFlash(short data, short address)
111:           {
112:           	GIE = 0;
02BA  138B     BCF INTCON, 0x7
113:           	PMCON1bits.CFGS = 0;
02BB  1315     BCF TMR0, 0x6
114:           	PMADRL = address & 0x00FF;
02BC  0872     MOVF i, W
02BD  0091     MOVWF PIR1
115:           	address >>= 8;
02BE  0873     MOVF i, W
02BF  00F2     MOVWF i
02C0  01F3     CLRF i
02C1  1BF2     BTFSC i, 0x7
02C2  03F3     DECF i, F
116:           	PMADRH = address & 0x00FF;
02C3  0092     MOVWF PIR2
117:           	PMCON1bits.FREE = 0;
02C4  1215     BCF TMR0, 0x4
118:           	PMCON1bits.LWLO = 1;
02C5  1695     BSF TMR0, 0x5
119:           	PMCON1bits.WREN = 1;
02C6  1515     BSF TMR0, 0x2
120:           	PMDATL = data & 0x00FF;
02C7  0870     MOVF i, W
02C8  0093     MOVWF PIR3
121:           	data >>= 8;
02C9  0871     MOVF i, W
02CA  00F0     MOVWF i
02CB  01F1     CLRF i
02CC  1BF0     BTFSC i, 0x7
02CD  03F1     DECF i, F
122:           	PMDATH = data & 0x00FF;
02CE  0094     MOVWF 0x14
123:           	PMCON1bits.LWLO = 0;
02CF  1295     BCF TMR0, 0x5
124:           	UnlockFlash();
02D0  2370     CALL 0x370
125:           	PMCON1bits.WREN = 0;
02D1  0023     MOVLB 0x3
02D2  1115     BCF TMR0, 0x2
126:           	GIE = 1;
02D3  178B     BSF INTCON, 0x7
127:           }
02D4  0008     RETURN
128:           void CommandSetTris()
129:           {
130:           	char data;
131:           	data = ReadCommandI2C();
017D  22D5     CALL 0x2D5
017E  00F3     MOVWF i
132:           	SendAck();
017F  128E     BCF PORTC, 0x5
0180  0020     MOVLB 0x0
0181  1E0E     BTFSS PORTC, 0x4
0182  2980     GOTO 0x180
0183  1A0E     BTFSC PORTC, 0x4
0184  2983     GOTO 0x183
0185  0021     MOVLB 0x1
0186  168E     BSF PORTC, 0x5
133:           
134:           	
135:           	GPIO0_TRIS = data & 0x01;
0187  3001     MOVLW 0x1
0188  0573     ANDWF i, W
0189  00F2     MOVWF i
018A  080C     MOVF PORTA, W
018B  0672     XORWF i, W
018C  39FE     ANDLW 0xFE
018D  0672     XORWF i, W
018E  008C     MOVWF PORTA
136:           	data >>= 1;
018F  36F3     LSRF i, F
137:           	GPIO1_TRIS = data & 0x01;
0190  0873     MOVF i, W
0191  3901     ANDLW 0x1
0192  00F2     MOVWF i
0193  0DF2     RLF i, F
0194  080C     MOVF PORTA, W
0195  0672     XORWF i, W
0196  39FD     ANDLW 0xFD
0197  0672     XORWF i, W
0198  008C     MOVWF PORTA
138:           	data >>= 1;
0199  36F3     LSRF i, F
139:           	GPIO2_TRIS = data & 0x01;
019A  0873     MOVF i, W
019B  3901     ANDLW 0x1
019C  00F2     MOVWF i
019D  0DF2     RLF i, F
019E  0DF2     RLF i, F
019F  080C     MOVF PORTA, W
01A0  0672     XORWF i, W
01A1  39FB     ANDLW 0xFB
01A2  0672     XORWF i, W
01A3  008C     MOVWF PORTA
140:           	data >>= 1;
01A4  36F3     LSRF i, F
141:           	GPIO3_TRIS = 1;
01A5  158C     BSF PORTA, 0x3
142:           	data >>= 1;
01A6  36F3     LSRF i, F
143:           	GPIO4_TRIS = data & 0x01;
01A7  0873     MOVF i, W
01A8  3901     ANDLW 0x1
01A9  00F2     MOVWF i
01AA  0EF2     SWAPF i, F
01AB  0DF2     RLF i, F
01AC  080C     MOVF PORTA, W
01AD  0672     XORWF i, W
01AE  39DF     ANDLW 0xDF
01AF  0672     XORWF i, W
01B0  008C     MOVWF PORTA
144:           	data >>= 1;
01B1  36F3     LSRF i, F
145:           	GPIO5_TRIS = data & 0x01;
01B2  0873     MOVF i, W
01B3  3901     ANDLW 0x1
01B4  00F2     MOVWF i
01B5  0DF2     RLF i, F
01B6  0DF2     RLF i, F
01B7  080E     MOVF PORTC, W
01B8  0672     XORWF i, W
01B9  39FB     ANDLW 0xFB
01BA  0672     XORWF i, W
01BB  008E     MOVWF PORTC
146:           	data >>= 1;
01BC  36F3     LSRF i, F
147:           	GPIO6_TRIS = data & 0x01;
01BD  0873     MOVF i, W
01BE  3901     ANDLW 0x1
01BF  00F2     MOVWF i
01C0  0DF2     RLF i, F
01C1  0DF2     RLF i, F
01C2  0DF2     RLF i, F
01C3  080E     MOVF PORTC, W
01C4  0672     XORWF i, W
01C5  39F7     ANDLW 0xF7
01C6  0672     XORWF i, W
01C7  008E     MOVWF PORTC
148:           
149:           }
01C8  0008     RETURN
150:           void CommandSetLat()
151:           {
152:           
153:           	char data;
154:           	data = ReadCommandI2C();
0131  22D5     CALL 0x2D5
155:           	SendAck();
0133  128E     BCF PORTC, 0x5
0134  0020     MOVLB 0x0
0135  1E0E     BTFSS PORTC, 0x4
0136  2934     GOTO 0x134
0137  1A0E     BTFSC PORTC, 0x4
0138  2937     GOTO 0x137
0139  0021     MOVLB 0x1
013A  168E     BSF PORTC, 0x5
156:           
157:           	
158:           	GPIO0_LAT = data & 0x01;
013B  3001     MOVLW 0x1
013C  0573     ANDWF i, W
013D  00F2     MOVWF i
013E  0022     MOVLB 0x2
013F  080C     MOVF PORTA, W
0140  0672     XORWF i, W
0141  39FE     ANDLW 0xFE
0142  0672     XORWF i, W
0143  008C     MOVWF PORTA
159:           	data >>= 1;
0144  36F3     LSRF i, F
160:           	GPIO1_LAT = data & 0x01;
0145  0873     MOVF i, W
0146  3901     ANDLW 0x1
0147  00F2     MOVWF i
0148  0DF2     RLF i, F
0149  080C     MOVF PORTA, W
014A  0672     XORWF i, W
014B  39FD     ANDLW 0xFD
014C  0672     XORWF i, W
014D  008C     MOVWF PORTA
161:           	data >>= 1;
014E  36F3     LSRF i, F
162:           	GPIO2_LAT = data & 0x01;
014F  0873     MOVF i, W
0150  3901     ANDLW 0x1
0151  00F2     MOVWF i
0152  0DF2     RLF i, F
0153  0DF2     RLF i, F
0154  080C     MOVF PORTA, W
0155  0672     XORWF i, W
0156  39FB     ANDLW 0xFB
0157  0672     XORWF i, W
0158  008C     MOVWF PORTA
163:           	data >>= 1;
0159  36F3     LSRF i, F
164:           //	GPIO3_LAT = command & 0x01;	GPIO3 is ALWAYS INPUT!!!
165:           	data >>= 1;
015A  36F3     LSRF i, F
166:           	GPIO4_LAT = data & 0x01;
015B  0873     MOVF i, W
015C  3901     ANDLW 0x1
015D  00F2     MOVWF i
015E  0EF2     SWAPF i, F
015F  0DF2     RLF i, F
0160  080C     MOVF PORTA, W
0161  0672     XORWF i, W
0162  39DF     ANDLW 0xDF
0163  0672     XORWF i, W
0164  008C     MOVWF PORTA
167:           	data >>= 1;
0165  36F3     LSRF i, F
168:           	GPIO5_LAT = data & 0x01;
0166  0873     MOVF i, W
0167  3901     ANDLW 0x1
0168  00F2     MOVWF i
0169  0DF2     RLF i, F
016A  0DF2     RLF i, F
016B  080E     MOVF PORTC, W
016C  0672     XORWF i, W
016D  39FB     ANDLW 0xFB
016E  0672     XORWF i, W
016F  008E     MOVWF PORTC
169:           	data >>= 1;
0170  36F3     LSRF i, F
170:           	GPIO6_LAT = data & 0x01;
0171  0873     MOVF i, W
0172  3901     ANDLW 0x1
0173  00F2     MOVWF i
0174  0DF2     RLF i, F
0175  0DF2     RLF i, F
0176  0DF2     RLF i, F
0177  080E     MOVF PORTC, W
0178  0672     XORWF i, W
0179  39F7     ANDLW 0xF7
017A  0672     XORWF i, W
017B  008E     MOVWF PORTC
171:           
172:           }
017C  0008     RETURN
173:           void CommandGetPort()
174:           {
175:           	char data;
176:           	data = GPIO6_PORT & 0x01;
0237  3000     MOVLW 0x0
0238  0020     MOVLB 0x0
0239  198E     BTFSC PORTC, 0x3
023A  3001     MOVLW 0x1
023B  00F4     MOVWF data
177:           	data <<= 1;
023C  35F4     LSLF data, F
178:           	data |= GPIO5_PORT & 0x01;
023D  0C0E     RRF PORTC, W
023E  0C89     RRF WREG, F
023F  3901     ANDLW 0x1
0240  04F4     IORWF data, F
179:           	data <<= 1;
0241  35F4     LSLF data, F
180:           	data |= GPIO4_PORT & 0x01;
0242  0E0C     SWAPF PORTA, W
0243  0C89     RRF WREG, F
0244  3901     ANDLW 0x1
0245  04F4     IORWF data, F
181:           	data <<= 1;
0246  35F4     LSLF data, F
182:           	data |= GPIO3_PORT & 0x01;
0247  0C0C     RRF PORTA, W
0248  00F3     MOVWF i
0249  0CF3     RRF i, F
024A  0C73     RRF i, W
024B  3901     ANDLW 0x1
024C  04F4     IORWF data, F
183:           	data <<= 1;
024D  35F4     LSLF data, F
184:           	data |= GPIO2_PORT & 0x01;
024E  0C0C     RRF PORTA, W
024F  0C89     RRF WREG, F
0250  3901     ANDLW 0x1
0251  04F4     IORWF data, F
185:           	data <<= 1;
0252  35F4     LSLF data, F
186:           	data |= GPIO1_PORT & 0x01;
0253  0C0C     RRF PORTA, W
0254  3901     ANDLW 0x1
0255  04F4     IORWF data, F
187:           	data <<= 1;
0256  35F4     LSLF data, F
188:           	data |= GPIO0_PORT & 0x01;
0257  080C     MOVF PORTA, W
0258  3901     ANDLW 0x1
0259  04F4     IORWF data, F
189:           
190:           	WriteByteI2C(data);
025A  0874     MOVF data, W
025B  2A9B     GOTO 0x29B
191:           
192:           
193:           }
025C  01F3     CLRF i
194:           void CommandGetTemp()
195:           {
196:           	/*DOING SOME CLOCK STRETCHING :) */
197:           	long int temp = 0;
198:           	SCL_TRIS = 0;
0304  0021     MOVLB 0x1
199:           	temp = ReadDataSPI();
0306  208B     CALL 0x8B
0307  0875     MOVF i, W
0308  00FD     MOVWF 0x7D
0309  0874     MOVF data, W
030A  00FC     MOVWF 0x7C
030B  0873     MOVF i, W
030C  00FB     MOVWF 0x7B
030D  0872     MOVF i, W
030E  00FA     MOVWF temp
200:           	SCL_TRIS = 1;
030F  0021     MOVLB 0x1
0310  160E     BSF PORTC, 0x4
201:           	WriteLongI2C(temp);
0311  087D     MOVF 0x7D, W
0312  00F3     MOVWF i
0313  087C     MOVF 0x7C, W
0314  00F2     MOVWF i
0315  087B     MOVF 0x7B, W
0316  00F1     MOVWF i
0317  087A     MOVF temp, W
0318  00F0     MOVWF i
0319  2A0A     GOTO 0x20A
202:           
203:           }
031A  0023     MOVLB 0x3
204:           void CommandSetPullUps()
205:           {
206:           	char data;
207:           	data = ReadCommandI2C();
01C9  22D5     CALL 0x2D5
01CA  00F3     MOVWF i
208:           	SendAck();
01CB  128E     BCF PORTC, 0x5
01CC  0020     MOVLB 0x0
01CD  1E0E     BTFSS PORTC, 0x4
01CE  29CC     GOTO 0x1CC
01CF  1A0E     BTFSC PORTC, 0x4
01D0  29CF     GOTO 0x1CF
01D1  0021     MOVLB 0x1
01D2  168E     BSF PORTC, 0x5
209:           
210:           	WPUAbits.WPUA0 = data & 0x01;
01D3  3001     MOVLW 0x1
01D4  0573     ANDWF i, W
01D5  00F2     MOVWF i
01D6  0024     MOVLB 0x4
01D7  080C     MOVF PORTA, W
01D8  0672     XORWF i, W
01D9  39FE     ANDLW 0xFE
01DA  0672     XORWF i, W
01DB  008C     MOVWF PORTA
211:           	data >>= 1;
01DC  36F3     LSRF i, F
212:           	WPUAbits.WPUA1 = data & 0x01;
01DD  0873     MOVF i, W
01DE  3901     ANDLW 0x1
01DF  00F2     MOVWF i
01E0  0DF2     RLF i, F
01E1  080C     MOVF PORTA, W
01E2  0672     XORWF i, W
01E3  39FD     ANDLW 0xFD
01E4  0672     XORWF i, W
01E5  008C     MOVWF PORTA
213:           	data >>= 1;
01E6  36F3     LSRF i, F
214:           	WPUAbits.WPUA2 = data & 0x01;
01E7  0873     MOVF i, W
01E8  3901     ANDLW 0x1
01E9  00F2     MOVWF i
01EA  0DF2     RLF i, F
01EB  0DF2     RLF i, F
01EC  080C     MOVF PORTA, W
01ED  0672     XORWF i, W
01EE  39FB     ANDLW 0xFB
01EF  0672     XORWF i, W
01F0  008C     MOVWF PORTA
215:           	data >>= 1;
01F1  36F3     LSRF i, F
216:           	WPUAbits.WPUA3 = data & 0x01;
01F2  0873     MOVF i, W
01F3  3901     ANDLW 0x1
01F4  00F2     MOVWF i
01F5  0DF2     RLF i, F
01F6  0DF2     RLF i, F
01F7  0DF2     RLF i, F
01F8  080C     MOVF PORTA, W
01F9  0672     XORWF i, W
01FA  39F7     ANDLW 0xF7
01FB  0672     XORWF i, W
01FC  008C     MOVWF PORTA
217:           	data >>= 1;
01FD  36F3     LSRF i, F
218:           	WPUAbits.WPUA5 = data & 0x01;
01FE  0873     MOVF i, W
01FF  3901     ANDLW 0x1
0200  00F2     MOVWF i
0201  0EF2     SWAPF i, F
0202  0DF2     RLF i, F
0203  080C     MOVF PORTA, W
0204  0672     XORWF i, W
0205  39DF     ANDLW 0xDF
0206  0672     XORWF i, W
0207  008C     MOVWF PORTA
219:           	data >>= 1;
0208  36F3     LSRF i, F
220:           
221:           }
0209  0008     RETURN
222:           void CommandSetAddress()
223:           {
224:           	char address;
225:           	address = ReadCommandI2C();
02ED  22D5     CALL 0x2D5
02EE  00F4     MOVWF data
226:           	SendAck();
02EF  128E     BCF PORTC, 0x5
02F0  0020     MOVLB 0x0
02F1  1E0E     BTFSS PORTC, 0x4
02F2  2AF0     GOTO 0x2F0
02F3  1A0E     BTFSC PORTC, 0x4
02F4  2AF3     GOTO 0x2F3
02F5  0021     MOVLB 0x1
02F6  168E     BSF PORTC, 0x5
227:           
228:           	/* STORE THE NEW ADDRESS INTO THE FLASH MEMORY */
229:           	EraseFlash(ADDR_MEM);
02F7  30F8     MOVLW 0xF8
02F8  00F0     MOVWF i
02F9  3007     MOVLW 0x7
02FA  00F1     MOVWF i
02FB  232F     CALL 0x32F
230:           	WriteFlash(address, ADDR_MEM);
02FC  0874     MOVF data, W
02FD  00F0     MOVWF i
02FE  30F8     MOVLW 0xF8
02FF  01F1     CLRF i
0300  00F2     MOVWF i
0301  3007     MOVLW 0x7
0302  00F3     MOVWF i
0303  2ABA     GOTO 0x2BA
231:           	ADDRESS = address;
232:           }
0304  0021     MOVLB 0x1
233:           void CommandGetAn(char channel)
234:           {
00E5  00FC     MOVWF 0x7C
235:           	long int result;
236:           
237:           	/* PORT INIT */
238:           
239:           	switch(channel)
00E6  28F6     GOTO 0xF6
00F6  087C     MOVF 0x7C, W
00F7  3A00     XORLW 0x0
00F8  1903     BTFSC STATUS, 0x2
00F9  28E7     GOTO 0xE7
00FA  3A01     XORLW 0x1
00FB  1903     BTFSC STATUS, 0x2
00FC  28EC     GOTO 0xEC
00FD  3A03     XORLW 0x3
00FE  1903     BTFSC STATUS, 0x2
00FF  28F1     GOTO 0xF1
0100  2901     GOTO 0x101
240:           	{
241:           	case 0:
242:           	{
243:           		TRISAbits.TRISA0 = 1;
00E7  0021     MOVLB 0x1
00E8  140C     BSF PORTA, 0x0
244:           		ANSELAbits.ANSA0 = 1;
00E9  0023     MOVLB 0x3
00EA  140C     BSF PORTA, 0x0
245:           	} break;
00EB  2901     GOTO 0x101
246:           	case 1:
247:           	{
248:           		TRISAbits.TRISA1 = 1;
00EC  0021     MOVLB 0x1
00ED  148C     BSF PORTA, 0x1
249:           		ANSELAbits.ANSA1 = 1;
00EE  0023     MOVLB 0x3
00EF  148C     BSF PORTA, 0x1
250:           	} break;
00F0  2901     GOTO 0x101
251:           	case 2:
252:           	{
253:           		TRISAbits.TRISA2 = 1;
00F1  0021     MOVLB 0x1
00F2  150C     BSF PORTA, 0x2
254:           		ANSELAbits.ANSA2 = 1;
00F3  0023     MOVLB 0x3
00F4  150C     BSF PORTA, 0x2
255:           	} break;
00F5  2901     GOTO 0x101
256:           
257:           
258:           	default: break;
259:           	}
260:           
261:           
262:           	/*CONFIG ADC*/
263:           	ADCON1bits.ADFM = 1;
0101  0021     MOVLB 0x1
0102  179E     BSF 0x1E, 0x7
264:           	ADCON1bits.ADCS = 0;
0103  308F     MOVLW 0x8F
0104  059E     ANDWF 0x1E, F
265:           	ADCON1bits.ADPREF = 0;
0105  30FC     MOVLW 0xFC
0106  059E     ANDWF 0x1E, F
266:           	ADCON0bits.CHS = channel;
0107  087C     MOVF 0x7C, W
0108  00F4     MOVWF data
0109  0DF4     RLF data, F
010A  0DF4     RLF data, F
010B  081D     MOVF 0x1D, W
010C  0674     XORWF data, W
010D  3983     ANDLW 0x83
010E  0674     XORWF data, W
010F  009D     MOVWF 0x1D
267:           	ADCON0bits.ADON = 1;
0110  141D     BSF 0x1D, 0x0
268:           
269:           	ADCON0bits.ADGO = 1;
0111  149D     BSF 0x1D, 0x1
270:           	while(ADCON0bits.ADGO) ;
0112  189D     BTFSC 0x1D, 0x1
0113  2912     GOTO 0x112
271:           
272:           	result = ADRESH;
0114  081C     MOVF T2CON, W
0115  00F8     MOVWF result
0116  01F9     CLRF 0x79
0117  01FA     CLRF temp
0118  01FB     CLRF 0x7B
273:           	result << = 8;
0119  087A     MOVF temp, W
011A  00FB     MOVWF 0x7B
011B  0879     MOVF 0x79, W
011C  00FA     MOVWF temp
011D  0878     MOVF result, W
011E  00F9     MOVWF 0x79
011F  01F8     CLRF result
274:           	result |= ADRESL;
0120  081B     MOVF PR2, W
0121  00F4     MOVWF data
0122  01F5     CLRF i
0123  01F6     CLRF 0x76
0124  01F7     CLRF 0x77
0125  04F8     IORWF result, F
0126  0875     MOVF i, W
0127  04F9     IORWF 0x79, F
0128  0876     MOVF 0x76, W
0129  04FA     IORWF temp, F
012A  0877     MOVF 0x77, W
012B  04FB     IORWF 0x7B, F
275:           
276:           	WriteWordI2C(result);
012C  0879     MOVF 0x79, W
012D  00F1     MOVWF i
012E  0878     MOVF result, W
012F  00F0     MOVWF i
0130  2A5C     GOTO 0x25C
277:           
278:           }
0131  22D5     CALL 0x2D5
279:           
280:           void StartSystem(void)
281:           {
282:           	unsigned char command;
283:               /*Loop until START condition is recieved*/
284:               StartI2C();
0008  2352     CALL 0x352
285:               
286:               
287:            
288:               /*Read the first bit of the address*/
289:               if ( ReadByteI2C(0x90))
0009  3090     MOVLW 0x90
000A  227C     CALL 0x27C
000B  3A00     XORLW 0x0
000C  1903     BTFSC STATUS, 0x2
000D  2883     GOTO 0x83
290:               {
291:           	    SendAck();
000E  128E     BCF PORTC, 0x5
000F  0020     MOVLB 0x0
0010  1E0E     BTFSS PORTC, 0x4
0011  280F     GOTO 0xF
0012  1A0E     BTFSC PORTC, 0x4
0013  2812     GOTO 0x12
0014  0021     MOVLB 0x1
0015  168E     BSF PORTC, 0x5
292:           
293:           	    /*Read the second bit of the address*/
294:           	    
295:           	    if (ReadByteI2C(0x01))
0016  3001     MOVLW 0x1
0017  227C     CALL 0x27C
0018  3A00     XORLW 0x0
0019  1903     BTFSC STATUS, 0x2
001A  287D     GOTO 0x7D
296:           	    {
297:           		    SendAck();
001B  128E     BCF PORTC, 0x5
001C  0020     MOVLB 0x0
001D  1E0E     BTFSS PORTC, 0x4
001E  281C     GOTO 0x1C
001F  1A0E     BTFSC PORTC, 0x4
0020  281F     GOTO 0x1F
0021  0021     MOVLB 0x1
0022  168E     BSF PORTC, 0x5
298:           		    
299:           
300:           		    /*Read the third bit of the address*/
301:           
302:           		    if(ReadByteI2C(0xA0))
0023  30A0     MOVLW 0xA0
0024  227C     CALL 0x27C
0025  3A00     XORLW 0x0
0026  1903     BTFSC STATUS, 0x2
0027  2876     GOTO 0x76
303:           		    {
304:           			    SendAck();
0028  128E     BCF PORTC, 0x5
0029  0020     MOVLB 0x0
002A  1E0E     BTFSS PORTC, 0x4
002B  2829     GOTO 0x29
002C  1A0E     BTFSC PORTC, 0x4
002D  282C     GOTO 0x2C
002E  0021     MOVLB 0x1
002F  168E     BSF PORTC, 0x5
305:           
306:           			    command = ReadCommandI2C();
0030  22D5     CALL 0x2D5
0031  0020     MOVLB 0x0
0032  00A8     MOVWF command
307:           
308:           			    SendAck();
0033  0021     MOVLB 0x1
0034  128E     BCF PORTC, 0x5
0035  0020     MOVLB 0x0
0036  1E0E     BTFSS PORTC, 0x4
0037  2835     GOTO 0x35
0038  1A0E     BTFSC PORTC, 0x4
0039  2838     GOTO 0x38
003A  0021     MOVLB 0x1
003B  168E     BSF PORTC, 0x5
309:           		
310:           			    switch(command)
003C  2855     GOTO 0x55
0055  0020     MOVLB 0x0
0056  0828     MOVF command, W
0057  3A01     XORLW 0x1
0058  1903     BTFSC STATUS, 0x2
0059  283D     GOTO 0x3D
005A  3A03     XORLW 0x3
005B  1903     BTFSC STATUS, 0x2
005C  283F     GOTO 0x3F
005D  3A01     XORLW 0x1
005E  1903     BTFSC STATUS, 0x2
005F  2841     GOTO 0x41
0060  3A07     XORLW 0x7
0061  1903     BTFSC STATUS, 0x2
0062  2843     GOTO 0x43
0063  3A14     XORLW 0x14
0064  1903     BTFSC STATUS, 0x2
0065  2845     GOTO 0x45
0066  3A01     XORLW 0x1
0067  1903     BTFSC STATUS, 0x2
0068  2848     GOTO 0x48
0069  3A07     XORLW 0x7
006A  1903     BTFSC STATUS, 0x2
006B  284B     GOTO 0x4B
006C  3A01     XORLW 0x1
006D  1903     BTFSC STATUS, 0x2
006E  284E     GOTO 0x4E
006F  3A36     XORLW 0x36
0070  1903     BTFSC STATUS, 0x2
0071  2851     GOTO 0x51
0072  3A91     XORLW 0x91
0073  1903     BTFSC STATUS, 0x2
0074  2853     GOTO 0x53
0075  287C     GOTO 0x7C
311:           			    {
312:           			    case SET_TRIS:	CommandSetTris();	break;
003D  217D     CALL 0x17D
003E  2888     GOTO 0x88
313:           			    case SET_LAT:	CommandSetLat();	break;
003F  2131     CALL 0x131
0040  2888     GOTO 0x88
314:           			    case GET_PORT:	CommandGetPort();	break;
0041  2237     CALL 0x237
0042  2888     GOTO 0x88
315:           			    case SET_PU:	CommandSetPullUps();	break;
0043  21C9     CALL 0x1C9
0044  2888     GOTO 0x88
316:           			    case GET_AN0:	CommandGetAn(0);	break;
0045  3000     MOVLW 0x0
0046  20E5     CALL 0xE5
0047  2888     GOTO 0x88
317:           			    case GET_AN1:	CommandGetAn(1);	break;
0048  3001     MOVLW 0x1
0049  20E5     CALL 0xE5
004A  2888     GOTO 0x88
318:           			    case GET_AN6:	CommandGetAn(6);	break;
004B  3006     MOVLW 0x6
004C  20E5     CALL 0xE5
004D  2888     GOTO 0x88
319:           			    case GET_AN7:	CommandGetAn(7);	break;
004E  3007     MOVLW 0x7
004F  20E5     CALL 0xE5
0050  2888     GOTO 0x88
320:           
321:           			    case GET_TEMP:	CommandGetTemp();	break;
0051  2304     CALL 0x304
0052  2888     GOTO 0x88
322:           			    
323:           			    case SET_ADDRESS:	CommandSetAddress();	break;
0053  22ED     CALL 0x2ED
0054  2888     GOTO 0x88
324:           
325:           			    default: break;
326:           			    }
327:           		 
328:           		    }
329:           
330:           		    else
331:           			    SendNack();
0076  0020     MOVLB 0x0
0077  1E0E     BTFSS PORTC, 0x4
0078  2876     GOTO 0x76
0079  1E0E     BTFSS PORTC, 0x4
007A  2888     GOTO 0x88
007B  2879     GOTO 0x79
332:           
333:           	    }
007C  2888     GOTO 0x88
334:           
335:           	    else
336:           		    SendNack();
007D  0020     MOVLB 0x0
007E  1E0E     BTFSS PORTC, 0x4
007F  287D     GOTO 0x7D
0080  1E0E     BTFSS PORTC, 0x4
0081  2888     GOTO 0x88
0082  2880     GOTO 0x80
337:               }
338:               else
339:           
340:           	    SendNack();
0083  0020     MOVLB 0x0
0084  1E0E     BTFSS PORTC, 0x4
0085  2883     GOTO 0x83
0086  1A0E     BTFSC PORTC, 0x4
0087  2886     GOTO 0x86
341:           
342:            //
343:               SDA_TRIS = 0;
0088  0021     MOVLB 0x1
0089  128E     BCF PORTC, 0x5
344:               /*Wait for STOP condition*/
345:               StopI2C();
008A  2B80     GOTO 0x380
346:               
347:           
348:           }
008B  0020     MOVLB 0x0
349:           
---  E:/Local Repository/MOD-TC/Software/trunk/WEB_files/Demo_Example_WEB_files/PIC-P26J50 + MOD-TC-MK2/MOD-TC/system.c
1:             /******************************************************************************/
2:             /*Files to Include                                                            */
3:             /******************************************************************************/
4:             
5:             #include <htc.h>           /* HiTech General Includes */
6:             #include <stdint.h>        /* For uint8_t definition */
7:             #include <stdbool.h>       /* For true/false definition */
8:             
9:             #include "system.h"
10:            
11:            /* Refer to the device datasheet for information about available
12:            oscillator configurations. */
13:            void ConfigureOscillator(void)
14:            {
15:            	//SET THE CLOCK 16MHz
16:            	OSCCONbits.IRCF = 0b1111;
0378  3078     MOVLW 0x78
0379  0021     MOVLB 0x1
037A  0499     IORWF T1GCON, F
17:            	OSCCONbits.SCS = 0b11;
037B  3003     MOVLW 0x3
037C  0499     IORWF T1GCON, F
18:            
19:            	while(!OSCSTATbits.HFIOFR);
037D  1A1A     BTFSC TMR2, 0x4
037E  0008     RETURN
037F  2B7D     GOTO 0x37D
20:            }
0380  0020     MOVLB 0x0
---  E:/Local Repository/MOD-TC/Software/trunk/WEB_files/Demo_Example_WEB_files/PIC-P26J50 + MOD-TC-MK2/MOD-TC/main.c
1:             /******************************************************************************/
2:             /* Files to Include                                                           */
3:             /******************************************************************************/
4:             
5:             #include <htc.h>           /* Global Header File */
6:             #include <stdint.h>        /* For uint8_t definition */
7:             #include <stdbool.h>       /* For true/false definition */
8:             
9:             #include "system.h"        /* System funct/params, like osc/peripheral config */
10:            #include "user.h"          /* User funct/params, such as InitApp */
11:            #include "OLIMEX.h"	   /* OLIMEX LTD Command List*/
12:            #include "i2c.h"
13:            #include "MAX31855.h"
14:            
15:            /******************************************************************************/
16:            /* User Global Variable Declaration                                           */
17:            /******************************************************************************/
18:            
19:            char ADDRESS;
20:            
21:            /******************************************************************************/
22:            /* Main Program                                                               */
23:            /******************************************************************************/
24:            
25:            uint8_t main(void)
26:            {
27:                /* Configure the oscillator for the device */
28:                ConfigureOscillator();
0360  2378     CALL 0x378
29:            
30:                /* Initialize I/O and Peripherals for application */
31:                InitApp();
0361  231A     CALL 0x31A
32:                TRISAbits.TRISA2 = 0;
0362  0021     MOVLB 0x1
0363  110C     BCF PORTA, 0x2
33:                LATAbits.LATA2 = 0;
0364  0022     MOVLB 0x2
0365  110C     BCF PORTA, 0x2
34:            
35:                /* Initialize device ID */
36:             //   InitAddress();
37:                /* Start the system loop*/
38:                while(1)
39:                {
40:            
41:            	    StartSystem();
0366  2008     CALL 0x8
0367  2B66     GOTO 0x366
42:            	    
43:            
44:            
45:            
46:                }
47:                
48:                
49:            
50:            }
0368  0021     MOVLB 0x1
51:            
---  E:/Local Repository/MOD-TC/Software/trunk/WEB_files/Demo_Example_WEB_files/PIC-P26J50 + MOD-TC-MK2/MOD-TC/interrupts.c
1:             /******************************************************************************/
2:             /*Files to Include                                                            */
3:             /******************************************************************************/
4:             
5:             #include <htc.h>            /* HiTech General Includes */
6:             #include <stdint.h>         /* For uint8_t definition */
7:             #include <stdbool.h>        /* For true/false definition */
8:             
9:             /******************************************************************************/
10:            /* Interrupt Routines                                                         */
11:            /******************************************************************************/
12:            
13:            void interrupt isr(void)
14:            {
0004  3180     MOVLP 0x0
15:                /* This code stub shows general interrupt handling.  Note that these
16:                conditional statements are not handled within 3 seperate if blocks.
17:                Do not use a seperate if block for each interrupt flag to avoid run
18:                time errors. */
19:            
20:            #if 0
21:                
22:                /* TODO Add High Priority interrupt routine code here. */
23:            
24:                /* Determine which flag generated the interrupt */
25:                if(<Interrupt Flag 1>)
26:                {
27:                    <Interrupt Flag 1=0>; /* Clear Interrupt Flag 1 */
28:                }
29:                else if (<Interrupt Flag 2>)
30:                {
31:                    <Interrupt Flag 2=0>; /* Clear Interrupt Flag 2 */
32:                }
33:                else
34:                {
35:                    /* Unhandled interrupts */
36:                }
37:            
38:            #endif
39:            
40:            }
0005  0009     RETFIE
---  E:/Local Repository/MOD-TC/Software/trunk/WEB_files/Demo_Example_WEB_files/PIC-P26J50 + MOD-TC-MK2/MOD-TC/i2c.c
1:             /******************************************************************************/
2:             /* Files to Include                                                           */
3:             /******************************************************************************/
4:             
5:             #include <htc.h>            /* HiTech General Includes */
6:             #include <stdint.h>         /* For uint8_t definition */
7:             #include <stdbool.h>        /* For true/false definition */
8:             
9:             #include "user.h"
10:            #include "OLIMEX.h"
11:            #include "i2c.h"
12:            
13:            /******************************************************************************/
14:            /* User Functions                                                             */
15:            /******************************************************************************/
16:            
17:            void StartI2C(void)
18:            {
19:            	if(!SDA_PORT)
0352  0020     MOVLB 0x0
20:            		while(!SDA_PORT);
0354  1E8E     BTFSS PORTC, 0x5
0355  2B54     GOTO 0x354
21:            	while(1)
22:            	{
23:            		while(SDA_PORT);
0356  1A8E     BTFSC PORTC, 0x5
0357  2B56     GOTO 0x356
24:            		if(SCL_PORT)
0358  1A0E     BTFSC PORTC, 0x4
0359  2B5D     GOTO 0x35D
25:            			break;
26:            		while(!SDA_PORT);
035A  1A8E     BTFSC PORTC, 0x5
035B  2B56     GOTO 0x356
035C  2B5A     GOTO 0x35A
27:            	}
28:            	while(SCL_PORT);
035D  1E0E     BTFSS PORTC, 0x4
035E  0008     RETURN
035F  2B5D     GOTO 0x35D
29:            }
0360  2378     CALL 0x378
30:            void StopI2C(void)
31:            {
32:            	while(!(SCL_PORT && SDA_PORT));
0380  0020     MOVLB 0x0
0381  1E0E     BTFSS PORTC, 0x4
0382  2B80     GOTO 0x380
0383  1A8E     BTFSC PORTC, 0x5
0384  0008     RETURN
0385  2B80     GOTO 0x380
33:            }
0386  0020     MOVLB 0x0
34:            unsigned char ReadCommandI2C(void)
35:            {
36:            	unsigned char data, i;
37:            	for(i = 8; i; i--)
02D5  3008     MOVLW 0x8
02D6  00F1     MOVWF i
02D7  08F1     MOVF i, F
02D8  1903     BTFSC STATUS, 0x2
02D9  2AE9     GOTO 0x2E9
02E7  03F1     DECF i, F
02E8  2AD7     GOTO 0x2D7
38:            	{
39:            		while(!SCL_PORT);
02DA  0020     MOVLB 0x0
02DB  1E0E     BTFSS PORTC, 0x4
02DC  2ADA     GOTO 0x2DA
40:            		data |= SDA_PORT;
02DD  0E0E     SWAPF PORTC, W
02DE  0C89     RRF WREG, F
02DF  3901     ANDLW 0x1
02E0  04F0     IORWF i, F
41:            		if (i != 1)
02E1  0371     DECF i, W
02E2  1903     BTFSC STATUS, 0x2
02E3  2AE7     GOTO 0x2E7
42:            		{
43:            			data <<= 1;
02E4  35F0     LSLF i, F
44:            			while(SCL_PORT);
02E5  1A0E     BTFSC PORTC, 0x4
02E6  2AE5     GOTO 0x2E5
45:            
46:            		}
47:            	}
48:            	SDA_TRIS = 0;
02E9  0021     MOVLB 0x1
02EA  128E     BCF PORTC, 0x5
49:            	return data;
02EB  0870     MOVF i, W
50:            }
02EC  0008     RETURN
51:            unsigned char ReadByteI2C(char compare)
52:            {
53:            	unsigned char data, i;
54:            	for(i = 8; i; i--)
027C  00F0     MOVWF i
027D  3008     MOVLW 0x8
027E  00F2     MOVWF i
027F  08F2     MOVF i, F
0280  1903     BTFSC STATUS, 0x2
0281  2A91     GOTO 0x291
028F  03F2     DECF i, F
0290  2A7F     GOTO 0x27F
55:            	{
56:            		while(!SCL_PORT);
0282  0020     MOVLB 0x0
0283  1E0E     BTFSS PORTC, 0x4
0284  2A82     GOTO 0x282
57:            		data |= SDA_PORT;
0285  0E0E     SWAPF PORTC, W
0286  0C89     RRF WREG, F
0287  3901     ANDLW 0x1
0288  04F1     IORWF i, F
58:            		if (i != 1)
0289  0372     DECF i, W
028A  1903     BTFSC STATUS, 0x2
028B  2A8F     GOTO 0x28F
59:            		{
60:            			data <<= 1;
028C  35F1     LSLF i, F
61:            			while(SCL_PORT);
028D  1A0E     BTFSC PORTC, 0x4
028E  2A8D     GOTO 0x28D
62:            			
63:            		}
64:            	}
65:            	if(data == compare)
0291  0871     MOVF i, W
0292  0670     XORWF i, W
0293  1D03     BTFSS STATUS, 0x2
0294  2A98     GOTO 0x298
66:            	{
67:            		SDA_TRIS = 0;
0295  0021     MOVLB 0x1
0296  128E     BCF PORTC, 0x5
68:            		return 1;
0297  3401     RETLW 0x1
69:            	}
70:            
71:            	SDA_TRIS = 1;
0298  0021     MOVLB 0x1
0299  168E     BSF PORTC, 0x5
72:            	return 0;
029A  3400     RETLW 0x0
73:            }
74:            void WriteByteI2C(char data)
75:            {
76:            	char i;
77:            	for(i = 0; i < 8; i++)
029B  00F1     MOVWF i
029C  01F2     CLRF i
02B2  3008     MOVLW 0x8
02B3  0AF2     INCF i, F
02B4  0272     SUBWF i, W
02B5  1C03     BTFSS STATUS, 0x0
02B6  2A9D     GOTO 0x29D
78:            	{
79:            
80:            		SDA_TRIS = (data & 0x80) ? 1 : 0 ;
029D  3000     MOVLW 0x0
029E  1BF1     BTFSC i, 0x7
029F  3001     MOVLW 0x1
02A0  00F0     MOVWF i
02A1  0EF0     SWAPF i, F
02A2  0DF0     RLF i, F
02A3  0021     MOVLB 0x1
02A4  080E     MOVF PORTC, W
02A5  0670     XORWF i, W
02A6  39DF     ANDLW 0xDF
02A7  0670     XORWF i, W
02A8  008E     MOVWF PORTC
81:            		if(i != 7) data <<= 1;
02A9  0872     MOVF i, W
02AA  3A07     XORLW 0x7
02AB  1D03     BTFSS STATUS, 0x2
02AC  35F1     LSLF i, F
82:            		while(!SCL_PORT);
02AD  0020     MOVLB 0x0
02AE  1E0E     BTFSS PORTC, 0x4
02AF  2AAD     GOTO 0x2AD
83:            		while(SCL_PORT);
02B0  1A0E     BTFSC PORTC, 0x4
02B1  2AB0     GOTO 0x2B0
84:            	}
85:            	SDA_TRIS = 1;
02B7  0021     MOVLB 0x1
02B8  168E     BSF PORTC, 0x5
86:            }
02B9  0008     RETURN
87:            void WriteLongI2C(long int data)
88:            {
89:            	int i;
90:            	for(i = 0; i < 32; i++)
020A  01F5     CLRF i
020B  01F6     CLRF 0x76
0226  0AF5     INCF i, F
0227  1903     BTFSC STATUS, 0x2
0228  0AF6     INCF 0x76, F
0229  0876     MOVF 0x76, W
022A  3A80     XORLW 0x80
022B  00FF     MOVWF 0x7F
022C  3080     MOVLW 0x80
022D  027F     SUBWF 0x7F, W
022E  1D03     BTFSS STATUS, 0x2
022F  2A32     GOTO 0x232
0230  3020     MOVLW 0x20
0231  0275     SUBWF i, W
0232  1C03     BTFSS STATUS, 0x0
0233  2A0C     GOTO 0x20C
91:            	{
92:            
93:            		SDA_TRIS = (data & 0x80000000) ? 1 : 0 ;
020C  3000     MOVLW 0x0
020D  1BF3     BTFSC i, 0x7
020E  3001     MOVLW 0x1
020F  00F4     MOVWF data
0210  0EF4     SWAPF data, F
0211  0DF4     RLF data, F
0212  0021     MOVLB 0x1
0213  080E     MOVF PORTC, W
0214  0674     XORWF data, W
0215  39DF     ANDLW 0xDF
0216  0674     XORWF data, W
0217  008E     MOVWF PORTC
94:            		if(i != 31) data <<= 1;
0218  0875     MOVF i, W
0219  3A1F     XORLW 0x1F
021A  0476     IORWF 0x76, W
021B  1903     BTFSC STATUS, 0x2
021C  2A21     GOTO 0x221
021D  35F0     LSLF i, F
021E  0DF1     RLF i, F
021F  0DF2     RLF i, F
0220  0DF3     RLF i, F
95:            		while(!SCL_PORT);
0221  0020     MOVLB 0x0
0222  1E0E     BTFSS PORTC, 0x4
0223  2A21     GOTO 0x221
96:            		while(SCL_PORT);
0224  1A0E     BTFSC PORTC, 0x4
0225  2A24     GOTO 0x224
97:            	}
98:            	SDA_TRIS = 1;
0234  0021     MOVLB 0x1
0235  168E     BSF PORTC, 0x5
99:            }
0236  0008     RETURN
100:           
101:           void WriteWordI2C(int data)
102:           {
103:           	char i;
104:           	for(i = 0; i < 16; i++)
025C  01F3     CLRF i
0274  3010     MOVLW 0x10
0275  0AF3     INCF i, F
0276  0273     SUBWF i, W
0277  1C03     BTFSS STATUS, 0x0
0278  2A5D     GOTO 0x25D
105:           	{
106:           
107:           		SDA_TRIS = (data & 0x8000) ? 1 : 0 ;
025D  3000     MOVLW 0x0
025E  1BF1     BTFSC i, 0x7
025F  3001     MOVLW 0x1
0260  00F2     MOVWF i
0261  0EF2     SWAPF i, F
0262  0DF2     RLF i, F
0263  0021     MOVLB 0x1
0264  080E     MOVF PORTC, W
0265  0672     XORWF i, W
0266  39DF     ANDLW 0xDF
0267  0672     XORWF i, W
0268  008E     MOVWF PORTC
108:           		if(i != 15) data <<= 1;
0269  0873     MOVF i, W
026A  3A0F     XORLW 0xF
026B  1903     BTFSC STATUS, 0x2
026C  2A6F     GOTO 0x26F
026D  35F0     LSLF i, F
026E  0DF1     RLF i, F
109:           		while(!SCL_PORT);
026F  0020     MOVLB 0x0
0270  1E0E     BTFSS PORTC, 0x4
0271  2A6F     GOTO 0x26F
110:           		while(SCL_PORT);
0272  1A0E     BTFSC PORTC, 0x4
0273  2A72     GOTO 0x272
111:           	}
112:           	SDA_TRIS = 1;
0279  0021     MOVLB 0x1
027A  168E     BSF PORTC, 0x5
113:           }
027B  0008     RETURN
114:           
115:           
116:           
---  E:/Local Repository/MOD-TC/Software/trunk/WEB_files/Demo_Example_WEB_files/PIC-P26J50 + MOD-TC-MK2/MOD-TC/MAX31855.c
1:             #include <htc.h>            /* HiTech General Includes */
2:             #include <stdint.h>         /* For uint8_t definition */
3:             #include <stdbool.h>        /* For true/false definition */
4:             
5:             #include "MAX31855.h"
6:             
7:             
8:             char InitSPI()
9:             {
10:            	MISO_INIT;
0368  0021     MOVLB 0x1
11:            	CLK_INIT;
036A  100E     BCF PORTC, 0x0
12:            	CS_INIT;
036B  120C     BCF PORTA, 0x4
13:            	CS_HIGH;
036C  0022     MOVLB 0x2
036D  160C     BSF PORTA, 0x4
14:            
15:            	DelaySPI();
036E  2341     CALL 0x341
16:            	DelaySPI();
036F  2B41     GOTO 0x341
17:            
18:            }
0370  3055     MOVLW 0x55
19:            void DelaySPI()
20:            {
21:            	int i;
22:            	for(i = 0; i < 100; i++);
0341  01F0     CLRF i
0342  01F1     CLRF i
0343  0AF0     INCF i, F
0344  1903     BTFSC STATUS, 0x2
0345  0AF1     INCF i, F
0346  0871     MOVF i, W
0347  3A80     XORLW 0x80
0348  00FF     MOVWF 0x7F
0349  3080     MOVLW 0x80
034A  027F     SUBWF 0x7F, W
034B  1D03     BTFSS STATUS, 0x2
034C  2B4F     GOTO 0x34F
034D  3064     MOVLW 0x64
034E  0270     SUBWF i, W
034F  1803     BTFSC STATUS, 0x0
0350  0008     RETURN
0351  2B43     GOTO 0x343
23:            }
0352  0020     MOVLB 0x0
24:            long int ReadDataSPI(void)
25:            {
26:            	long int data = 0, i;
008B  0020     MOVLB 0x0
27:            
28:            	CS_LOW;
0090  0022     MOVLB 0x2
0091  120C     BCF PORTA, 0x4
29:            	DelaySPI();
0092  2341     CALL 0x341
30:            
31:            	for(i = 0; i < 32; i++)
0093  0020     MOVLB 0x0
0094  01A4     CLRF i
0095  01A5     CLRF 0x25
0096  01A6     CLRF 0x26
0097  01A7     CLRF 0x27
00BA  0020     MOVLB 0x0
00BB  0AA4     INCF i, F
00BC  1903     BTFSC STATUS, 0x2
00BD  0AA5     INCF 0x25, F
00BE  1903     BTFSC STATUS, 0x2
00BF  0AA6     INCF 0x26, F
00C0  1903     BTFSC STATUS, 0x2
00C1  0AA7     INCF 0x27, F
00C2  0827     MOVF 0x27, W
00C3  3A80     XORLW 0x80
00C4  00FF     MOVWF 0x7F
00C5  3080     MOVLW 0x80
00C6  027F     SUBWF 0x7F, W
00C7  1D03     BTFSS STATUS, 0x2
00C8  28D3     GOTO 0xD3
00C9  3000     MOVLW 0x0
00CA  0226     SUBWF 0x26, W
00CB  1D03     BTFSS STATUS, 0x2
00CC  28D3     GOTO 0xD3
00CD  3000     MOVLW 0x0
00CE  0225     SUBWF 0x25, W
00CF  1D03     BTFSS STATUS, 0x2
00D0  28D3     GOTO 0xD3
00D1  3020     MOVLW 0x20
00D2  0224     SUBWF i, W
00D3  1C03     BTFSS STATUS, 0x0
00D4  2898     GOTO 0x98
32:            	{
33:            		CLK = 1;
0098  0022     MOVLB 0x2
0099  140E     BSF PORTC, 0x0
34:            		DelaySPI();
009A  2341     CALL 0x341
35:            		data |= (MISO & 0x01) ? 1 : 0;
009B  3000     MOVLW 0x0
009C  0020     MOVLB 0x0
009D  188E     BTFSC PORTC, 0x1
009E  3001     MOVLW 0x1
009F  00F6     MOVWF 0x76
00A0  01F7     CLRF 0x77
00A1  01F8     CLRF result
00A2  01F9     CLRF 0x79
00A3  04A0     IORWF data, F
00A4  0877     MOVF 0x77, W
00A5  04A1     IORWF 0x21, F
00A6  0878     MOVF result, W
00A7  04A2     IORWF 0x22, F
00A8  0879     MOVF 0x79, W
00A9  04A3     IORWF 0x23, F
36:            
37:            		if( i != 31) data <<= 1;
00AA  0824     MOVF i, W
00AB  3A1F     XORLW 0x1F
00AC  0425     IORWF 0x25, W
00AD  0426     IORWF 0x26, W
00AE  0427     IORWF 0x27, W
00AF  1903     BTFSC STATUS, 0x2
00B0  28B5     GOTO 0xB5
00B1  35A0     LSLF data, F
00B2  0DA1     RLF 0x21, F
00B3  0DA2     RLF 0x22, F
00B4  0DA3     RLF 0x23, F
38:            
39:            
40:            		DelaySPI();
00B5  2341     CALL 0x341
41:            		CLK = 0;
00B6  0022     MOVLB 0x2
00B7  100E     BCF PORTC, 0x0
42:            		DelaySPI();
00B8  2341     CALL 0x341
43:            		DelaySPI();
00B9  2341     CALL 0x341
44:            	}
45:            
46:            
47:            	DelaySPI();
00D5  2341     CALL 0x341
48:            	DelaySPI();
00D6  2341     CALL 0x341
49:            	CS_HIGH;
00D7  0022     MOVLB 0x2
00D8  160C     BSF PORTA, 0x4
50:            
51:            	DelaySPI();
00D9  2341     CALL 0x341
52:            	DelaySPI();
00DA  2341     CALL 0x341
53:            
54:            	return data;
00DB  0020     MOVLB 0x0
00DC  0823     MOVF 0x23, W
00DD  00F5     MOVWF i
00DE  0822     MOVF 0x22, W
00DF  00F4     MOVWF data
00E0  0821     MOVF 0x21, W
00E1  00F3     MOVWF i
00E2  0820     MOVF data, W
00E3  00F2     MOVWF i
55:            }
00E4  0008     RETURN
56:            
