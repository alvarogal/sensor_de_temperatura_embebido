diff -Naur openocd-0.7.0/configure.ac openocd-0.7.0_stamp/configure.ac
--- openocd-0.7.0/configure.ac	2013-05-05 07:46:00.000000000 +0000
+++ openocd-0.7.0_stamp/configure.ac	2013-05-23 14:19:09.330000339 +0000
@@ -29,6 +29,9 @@
 AC_PROG_LIBTOOL
 AC_SUBST([LIBTOOL_DEPS])
 
++CFLAGS="$CFLAGS -std=gnu99"
+
+
 dnl configure checks required for Jim files (these are obsolete w/ C99)
 AC_C_CONST
 AC_TYPE_LONG_LONG_INT
@@ -168,21 +171,21 @@
 test x"$OCDxprefix" = xNONE && OCDxprefix="$OCDprefix"
 
 # what matters is the "exec-prefix"
-if test "$OCDxprefix" != "$ac_default_prefix"
-then
+#if test "$OCDxprefix" != "$ac_default_prefix"
+#then
     # We are installing in a non-standard place
     # Nonstandard --prefix and/or --exec-prefix
     # We have an override of some sort.
     # use build specific install library dir
-
-    LDFLAGS="$LDFLAGS -L$OCDxprefix/lib"
-    # RPATH becomes an issue on Linux only
-    if test $host_os = linux-gnu || test $host_os = linux ; then
-      LDFLAGS="$LDFLAGS -Wl,-rpath,$OCDxprefix/lib"
-    fi
+#
+#    LDFLAGS="$LDFLAGS -L$OCDxprefix/lib"
+#    # RPATH becomes an issue on Linux only
+#    if test $host_os = linux-gnu || test $host_os = linux ; then
+#      LDFLAGS="$LDFLAGS -Wl,-rpath,$OCDxprefix/lib"
+#    fi
     # The "INCDIR" is also usable
-    CFLAGS="$CFLAGS -I$includedir"
-fi
+#    CFLAGS="$CFLAGS -I$includedir"
+#fi
 
 AC_ARG_WITH(ftd2xx,
    AS_HELP_STRING([--with-ftd2xx=<PATH>],[This option has been removed.]),
@@ -422,11 +425,22 @@
     AC_ARG_ENABLE([at91rm9200],
       AS_HELP_STRING([--enable-at91rm9200], [Enable building support for AT91RM9200 based SBCs]),
       [build_at91rm9200=$enableval], [build_at91rm9200=no])
+
+    AC_ARG_ENABLE([imx233],
+      AS_HELP_STRING([--enable-imx233], [Enable building support for IMX233 based SBCs]),
+      [build_imx233=$enableval], [build_imx233=yes])
+
+    AC_ARG_ENABLE([imx233_mini],
+      AS_HELP_STRING([--enable-imx233_mini], [Enable building support for STAMP_mini based SBCs]),
+      [build_imx233=$enableval], [build_imx233_mini=yes])
+
     ;;
 
   *)
     build_ep93xx=no
     build_at91rm9200=no
+    build_imx233=yes
+    build_imx233_mini=yes
     ;;
 esac
 
@@ -664,6 +678,21 @@
   AC_DEFINE([BUILD_AT91RM9200], [0], [0 if you don't want at91rm9200.])
 fi
 
+if test $build_imx233 = yes; then
+  build_bitbang=yes
+  AC_DEFINE([BUILD_IMX233], [1], [1 if you want imx233.])
+else
+  AC_DEFINE([BUILD_IMX233], [0], [0 if you don't want imx233.])
+fi
+
+if test $build_imx233_mini = yes; then
+  build_bitbang=yes
+  AC_DEFINE([BUILD_IMX233_MINI], [1], [1 if you want imx233_mini.])
+else
+  AC_DEFINE([BUILD_IMX233_MINI], [0], [0 if you don't want imx233_mini.])
+fi
+
+
 if test x$parport_use_ppdev = xyes; then
   AC_DEFINE([PARPORT_USE_PPDEV], [1], [1 if you want parport to use ppdev.])
 else
@@ -1177,6 +1206,8 @@
 AM_CONDITIONAL([ZY1000_MASTER], [test $build_zy1000_master = yes])
 AM_CONDITIONAL([IOUTIL], [test $build_ioutil = yes])
 AM_CONDITIONAL([AT91RM9200], [test $build_at91rm9200 = yes])
+AM_CONDITIONAL([IMX233], [test $build_imx233 = yes])
+AM_CONDITIONAL([IMX233_MINI], [test $build_imx233_mini = yes])
 AM_CONDITIONAL([BITBANG], [test $build_bitbang = yes])
 AM_CONDITIONAL([FT2232_LIBFTDI], [test $build_ft2232_libftdi = yes])
 AM_CONDITIONAL([FT2232_DRIVER], [test $build_ft2232_ftd2xx = yes -o $build_ft2232_libftdi = yes])
diff -Naur openocd-0.7.0/configure.ac~ openocd-0.7.0_stamp/configure.ac~
--- openocd-0.7.0/configure.ac~	1970-01-01 00:00:00.000000000 +0000
+++ openocd-0.7.0_stamp/configure.ac~	2013-05-23 13:34:51.360000021 +0000
@@ -0,0 +1,1359 @@
+AC_PREREQ(2.60)
+AC_INIT([openocd], [0.7.0],
+  [OpenOCD Mailing List <openocd-devel@lists.sourceforge.net>])
+AC_CONFIG_SRCDIR([src/openocd.c])
+
+m4_include([config_subdir.m4])dnl
+
+AM_INIT_AUTOMAKE([-Wall -Wno-portability dist-bzip2 dist-zip])
+AM_MAINTAINER_MODE
+
+AC_CONFIG_HEADERS([config.h])
+AH_BOTTOM([
+#include <helper/system.h>
+#include <helper/types.h>
+#include <helper/replacements.h>
+])
+
+AC_LANG_C
+AC_PROG_CC
+AC_PROG_CC_C99
+AM_PROG_CC_C_O
+AC_PROG_RANLIB
+
+dnl disable checks for C++, Fortran and GNU Java Compiler
+m4_defun([_LT_AC_LANG_CXX_CONFIG], [:])
+m4_defun([_LT_AC_LANG_F77_CONFIG], [:])
+m4_defun([_LT_AC_LANG_GCJ_CONFIG], [:])
+AC_DISABLE_SHARED
+AC_PROG_LIBTOOL
+AC_SUBST([LIBTOOL_DEPS])
+
++CFLAGS="$CFLAGS -std=gnu99"
+
+
+dnl configure checks required for Jim files (these are obsolete w/ C99)
+AC_C_CONST
+AC_TYPE_LONG_LONG_INT
+
+AC_SEARCH_LIBS([ioperm], [ioperm])
+AC_SEARCH_LIBS([dlopen], [dl])
+
+AC_CHECK_HEADERS([sys/socket.h])
+AC_CHECK_HEADERS([arpa/inet.h], [], [], [dnl
+#include <stdio.h>
+#ifdef STDC_HEADERS
+# include <stdlib.h>
+# include <stddef.h>
+#else
+# ifdef HAVE_STDLIB_H
+#  include <stdlib.h>
+# endif
+#endif
+#ifdef HAVE_SYS_SOCKET_H
+# include <sys/socket.h>
+#endif
+])
+AC_CHECK_HEADERS([elf.h])
+AC_CHECK_HEADERS([dirent.h])
+AC_CHECK_HEADERS([fcntl.h])
+AC_CHECK_HEADERS([ifaddrs.h], [], [], [dnl
+#include <stdio.h>
+#ifdef STDC_HEADERS
+# include <stdlib.h>
+# include <stddef.h>
+#else
+# ifdef HAVE_STDLIB_H
+#  include <stdlib.h>
+# endif
+#endif
+#ifdef HAVE_SYS_SOCKET_H
+# include <sys/socket.h>
+#endif
+])
+AC_CHECK_HEADERS([malloc.h])
+AC_CHECK_HEADERS([netdb.h])
+AC_CHECK_HEADERS([netinet/in.h], [], [], [dnl
+#include <stdio.h>
+#ifdef STDC_HEADERS
+# include <stdlib.h>
+# include <stddef.h>
+#else
+# ifdef HAVE_STDLIB_H
+#  include <stdlib.h>
+# endif
+#endif
+#ifdef HAVE_SYS_SOCKET_H
+# include <sys/socket.h>
+#endif
+])
+AC_CHECK_HEADERS([netinet/tcp.h], [], [], [dnl
+#include <stdio.h>
+#ifdef STDC_HEADERS
+# include <stdlib.h>
+# include <stddef.h>
+#else
+# ifdef HAVE_STDLIB_H
+#  include <stdlib.h>
+# endif
+#endif
+#ifdef HAVE_SYS_SOCKET_H
+# include <sys/socket.h>
+#endif
+])
+AC_CHECK_HEADERS([pthread.h])
+AC_CHECK_HEADERS([strings.h])
+AC_CHECK_HEADERS([sys/ioctl.h])
+AC_CHECK_HEADERS([sys/param.h])
+AC_CHECK_HEADERS([sys/poll.h])
+AC_CHECK_HEADERS([sys/select.h])
+AC_CHECK_HEADERS([sys/stat.h])
+AC_CHECK_HEADERS([sys/time.h])
+AC_CHECK_HEADERS([sys/types.h])
+AC_CHECK_HEADERS([unistd.h])
+AC_CHECK_HEADERS([net/if.h], [], [], [dnl
+#include <stdio.h>
+#ifdef STDC_HEADERS
+# include <stdlib.h>
+# include <stddef.h>
+#else
+# ifdef HAVE_STDLIB_H
+#  include <stdlib.h>
+# endif
+#endif
+#ifdef HAVE_SYS_SOCKET_H
+# include <sys/socket.h>
+#endif
+])
+
+AC_HEADER_ASSERT
+AC_HEADER_STDBOOL
+AC_HEADER_TIME
+
+AC_C_BIGENDIAN
+
+AC_CHECK_FUNCS([strndup])
+AC_CHECK_FUNCS([strnlen])
+AC_CHECK_FUNCS([gettimeofday])
+AC_CHECK_FUNCS([usleep])
+AC_CHECK_FUNCS([vasprintf])
+
+build_bitbang=no
+build_bitq=no
+is_cygwin=no
+is_mingw=no
+is_win32=no
+is_darwin=no
+
+# guess-rev.sh only exists in the repository, not in the released archives
+AC_MSG_CHECKING([whether to build a release])
+if test -x $srcdir/guess-rev.sh ; then
+  build_release=no
+else
+  build_release=yes
+fi
+AC_MSG_RESULT([$build_release])
+
+# We are not *ALWAYS* being installed in the standard place.
+# We may be installed in a "tool-build" specific location.
+# Normally with other packages - as part of a tool distro.
+# Thus - we should search that 'libdir' also.
+#
+# And - if we are being installed there - the odds are
+# The libraries unique to what we are are there too.
+#
+
+# Expand nd deal with NONE - just like configure will do later
+OCDprefix=$prefix
+OCDxprefix=$exec_prefix
+test x"$OCDprefix"  = xNONE && OCDprefix=$ac_default_prefix
+# Let make expand exec_prefix.
+test x"$OCDxprefix" = xNONE && OCDxprefix="$OCDprefix"
+
+# what matters is the "exec-prefix"
+if test "$OCDxprefix" != "$ac_default_prefix"
+then
+    # We are installing in a non-standard place
+    # Nonstandard --prefix and/or --exec-prefix
+    # We have an override of some sort.
+    # use build specific install library dir
+
+    LDFLAGS="$LDFLAGS -L$OCDxprefix/lib"
+    # RPATH becomes an issue on Linux only
+    if test $host_os = linux-gnu || test $host_os = linux ; then
+      LDFLAGS="$LDFLAGS -Wl,-rpath,$OCDxprefix/lib"
+    fi
+    # The "INCDIR" is also usable
+    CFLAGS="$CFLAGS -I$includedir"
+fi
+
+AC_ARG_WITH(ftd2xx,
+   AS_HELP_STRING([--with-ftd2xx=<PATH>],[This option has been removed.]),
+  [
+# Option Given.
+cat << __EOF__
+
+The option: --with-ftd2xx=<PATH> has been removed.
+On Linux, the new option is:
+
+  --with-ftd2xx-linux-tardir=/path/to/files
+
+Where <path> is the path the the directory where the "tar.gz" file
+from FTDICHIP.COM was unpacked, for example:
+
+  --with-ftd2xx-linux-tardir=${HOME}/libftd2xx0.4.16
+
+On Cygwin/MingW32, the new option is:
+
+  --with-ftd2xx-win32-zipdir=/path/to/files
+
+Where <path> is the path to the directory where the "zip" file from
+FTDICHIP.COM was unpacked, for example:
+
+  --with-ftd2xx-win32-zipdir=${HOME}/ftd2xx.cdm.files
+
+__EOF__
+
+   AC_MSG_ERROR([Sorry Cannot continue])
+  ], [true])
+
+#========================================
+# FTD2XXX support comes in 4 forms.
+#    (1) win32 - via a zip file
+#    (2) linux - via a tar file
+#    (3) linux/cygwin/mingw - via libftdi
+#    (4) darwin - installed under /usr/local
+#
+# In case (1) and (2) we need to know where the package was unpacked.
+
+AC_ARG_WITH(ftd2xx-win32-zipdir,
+  AS_HELP_STRING([--with-ftd2xx-win32-zipdir],[Where (CYGWIN/MINGW) the zip file from ftdichip.com was unpacked (default=search)]),
+  [
+  # option present
+  if test -d $with_ftd2xx_win32_zipdir
+  then
+    with_ftd2xx_win32_zipdir=`cd $with_ftd2xx_win32_zipdir && pwd`
+    AC_MSG_NOTICE([Using: ftdichip.com library: $with_ftd2xx_win32_zipdir])
+  else
+    AC_MSG_ERROR([Parameter to --with-ftd2xx-win32-zipdir is not a dir: $with_ftd2xx_win32_zipdir])
+  fi
+  ], [true])
+
+AC_ARG_WITH(ftd2xx-linux-tardir,
+  AS_HELP_STRING([--with-ftd2xx-linux-tardir], [Where (Linux/Unix) the tar file from ftdichip.com was unpacked (default=search)]),
+  [
+  # Option present
+  if test $is_win32 = yes ; then
+     AC_MSG_ERROR([The option: --with-ftd2xx-linux-tardir is only usable on linux])
+  fi
+  if test -d $with_ftd2xx_linux_tardir
+  then
+    with_ftd2xx_linux_tardir=`cd $with_ftd2xx_linux_tardir && pwd`
+    AC_MSG_NOTICE([Using: ftdichip.com library: $with_ftd2xx_linux_tardir])
+  else
+    AC_MSG_ERROR([Parameter to --with-ftd2xx-linux-tardir is not a dir: $with_ftd2xx_linux_tardir])
+  fi
+  ], [true])
+
+AC_ARG_WITH(ftd2xx-lib,
+  AS_HELP_STRING([--with-ftd2xx-lib],
+    [Use static or shared ftd2xx libs (default=static)]),
+  [
+  case "$withval" in
+  static)
+    with_ftd2xx_lib=$withval
+    ;;
+  shared)
+    with_ftd2xx_lib=$withval
+    ;;
+  *)
+    AC_MSG_ERROR([Option: --with-ftd2xx-lib=static or --with-ftd2xx-lib=shared not, $withval])
+    ;;
+  esac
+  ], [
+  # Default is static - it is simpler :-(
+  with_ftd2xx_lib=static
+  ])
+
+AC_ARG_ENABLE([doxygen-html],
+  AS_HELP_STRING([--disable-doxygen-html],
+    [Disable building Doxygen manual as HTML.]),
+  [doxygen_as_html=$enableval], [doxygen_as_html=yes])
+AC_SUBST([doxygen_as_html])
+AC_MSG_CHECKING([whether to build Doxygen as HTML])
+AC_MSG_RESULT([$doxygen_as_html])
+
+AC_ARG_ENABLE([doxygen-pdf],
+  AS_HELP_STRING([--enable-doxygen-pdf],
+    [Enable building Doxygen manual as PDF.]),
+  [doxygen_as_pdf=$enableval], [doxygen_as_pdf=no])
+AC_SUBST([doxygen_as_pdf])
+AC_MSG_CHECKING([whether to build Doxygen as PDF])
+AC_MSG_RESULT([$doxygen_as_pdf])
+
+AC_ARG_ENABLE([gccwarnings],
+  AS_HELP_STRING([--disable-gccwarnings], [Disable compiler warnings]),
+  [gcc_warnings=$enableval], [gcc_warnings=yes])
+
+AC_ARG_ENABLE([wextra],
+  AS_HELP_STRING([--disable-wextra], [Disable extra compiler warnings]),
+  [gcc_wextra=$enableval], [gcc_wextra=$gcc_warnings])
+
+AC_ARG_ENABLE([werror],
+  AS_HELP_STRING([--disable-werror], [Do not treat warnings as errors]),
+  [gcc_werror=$enableval], [gcc_werror=$gcc_warnings])
+
+# set default verbose options, overridden by following options
+debug_jtag_io=no
+debug_usb_io=no
+debug_usb_comms=no
+
+AC_ARG_ENABLE([verbose],
+  AS_HELP_STRING([--enable-verbose],
+      [Enable verbose JTAG I/O messages (for debugging).]),
+  [
+  debug_jtag_io=$enableval
+  debug_usb_io=$enableval
+  debug_usb_comms=$enableval
+  ], [])
+
+AC_ARG_ENABLE([verbose_jtag_io],
+  AS_HELP_STRING([--enable-verbose-jtag-io],
+      [Enable verbose JTAG I/O messages (for debugging).]),
+  [debug_jtag_io=$enableval], [])
+
+AC_ARG_ENABLE([verbose_usb_io],
+  AS_HELP_STRING([--enable-verbose-usb-io],
+      [Enable verbose USB I/O messages (for debugging)]),
+  [debug_usb_io=$enableval], [])
+
+AC_ARG_ENABLE([verbose_usb_comms],
+  AS_HELP_STRING([--enable-verbose-usb-comms],
+      [Enable verbose USB communication messages (for debugging)]),
+  [debug_usb_comms=$enableval], [])
+
+AC_MSG_CHECKING([whether to enable verbose JTAG I/O messages]);
+AC_MSG_RESULT([$debug_jtag_io])
+if test $debug_jtag_io = yes; then
+  AC_DEFINE([_DEBUG_JTAG_IO_],[1], [Print verbose JTAG I/O messages])
+fi
+
+AC_MSG_CHECKING([whether to enable verbose USB I/O messages]);
+AC_MSG_RESULT([$debug_usb_io])
+if test $debug_usb_io = yes; then
+  AC_DEFINE([_DEBUG_USB_IO_],[1], [Print verbose USB I/O messages])
+fi
+
+AC_MSG_CHECKING([whether to enable verbose USB communication messages]);
+AC_MSG_RESULT([$debug_usb_comms])
+if test $debug_usb_comms = yes; then
+  AC_DEFINE([_DEBUG_USB_COMMS_],[1], [Print verbose USB communication messages])
+fi
+
+debug_malloc=no
+AC_ARG_ENABLE([malloc_logging],
+  AS_HELP_STRING([--enable-malloc-logging],
+      [Include free space in logging messages (requires malloc.h).]),
+  [debug_malloc=$enableval], [])
+
+AC_MSG_CHECKING([whether to enable malloc free space logging]);
+AC_MSG_RESULT([$debug_malloc])
+if test $debug_malloc = yes; then
+  AC_DEFINE([_DEBUG_FREE_SPACE_],[1], [Include malloc free space in logging])
+fi
+
+AC_ARG_ENABLE([dummy],
+  AS_HELP_STRING([--enable-dummy], [Enable building the dummy port driver]),
+  [build_dummy=$enableval], [build_dummy=no])
+
+AC_ARG_ENABLE([parport],
+  AS_HELP_STRING([--enable-parport], [Enable building the pc parallel port driver]),
+  [build_parport=$enableval], [build_parport=no])
+
+AC_ARG_ENABLE([parport_ppdev],
+  AS_HELP_STRING([--disable-parport-ppdev],
+      [Disable use of ppdev (/dev/parportN) for parport (for x86 only)]),
+    [parport_use_ppdev=$enableval], [parport_use_ppdev=yes])
+
+AC_ARG_ENABLE([parport_giveio],
+    AS_HELP_STRING([--enable-parport-giveio],
+      [Enable use of giveio for parport (for CygWin only)]),
+    [parport_use_giveio=$enableval], [parport_use_giveio=])
+
+AC_ARG_ENABLE([ft2232_libftdi],
+  AS_HELP_STRING([--enable-ft2232_libftdi], [Enable building support for FT2232 based devices using the libftdi driver, opensource alternate of FTD2XX]),
+  [build_ft2232_libftdi=$enableval], [build_ft2232_libftdi=no])
+
+AC_ARG_ENABLE([ft2232_ftd2xx],
+  AS_HELP_STRING([--enable-ft2232_ftd2xx], [Enable building support for FT2232 based devices using the FTD2XX driver from ftdichip.com]),
+  [build_ft2232_ftd2xx=$enableval], [build_ft2232_ftd2xx=no])
+
+AC_ARG_ENABLE([ftdi],
+  AS_HELP_STRING([--enable-ftdi], [Enable building support for the MPSSE mode of FTDI based devices, using libusb-1.0 in asynchronous mode]),
+  [build_ftdi=$enableval], [build_ftdi=no])
+
+AC_ARG_ENABLE([usb_blaster_libftdi],
+  AS_HELP_STRING([--enable-usb_blaster_libftdi], [Enable building support for the Altera USB-Blaster using the libftdi driver, opensource alternate of FTD2XX]),
+  [build_usb_blaster_libftdi=$enableval], [build_usb_blaster_libftdi=no])
+
+AC_ARG_ENABLE([usb_blaster_ftd2xx],
+  AS_HELP_STRING([--enable-usb_blaster_ftd2xx], [Enable building support for the Altera USB-Blaster using the FTD2XX driver from ftdichip.com]),
+  [build_usb_blaster_ftd2xx=$enableval], [build_usb_blaster_ftd2xx=no])
+
+AC_ARG_ENABLE([amtjtagaccel],
+  AS_HELP_STRING([--enable-amtjtagaccel], [Enable building the Amontec JTAG-Accelerator driver]),
+  [build_amtjtagaccel=$enableval], [build_amtjtagaccel=no])
+
+AC_ARG_ENABLE([zy1000_master],
+  AS_HELP_STRING([--enable-zy1000-master], [Use ZY1000 JTAG master registers]),
+  [build_zy1000_master=$enableval], [build_zy1000_master=no])
+
+AC_ARG_ENABLE([zy1000],
+  AS_HELP_STRING([--enable-zy1000], [Enable ZY1000 interface]),
+  [build_zy1000=$enableval], [build_zy1000=no])
+
+AC_ARG_ENABLE([ioutil],
+  AS_HELP_STRING([--enable-ioutil], [Enable ioutil functions - useful for standalone OpenOCD implementations]),
+  [build_ioutil=$enableval], [build_ioutil=no])
+
+case "${host_cpu}" in
+  arm*)
+    AC_ARG_ENABLE([ep93xx],
+      AS_HELP_STRING([--enable-ep93xx], [Enable building support for EP93xx based SBCs]),
+      [build_ep93xx=$enableval], [build_ep93xx=no])
+
+    AC_ARG_ENABLE([at91rm9200],
+      AS_HELP_STRING([--enable-at91rm9200], [Enable building support for AT91RM9200 based SBCs]),
+      [build_at91rm9200=$enableval], [build_at91rm9200=no])
+
+    AC_ARG_ENABLE([imx233],
+      AS_HELP_STRING([--enable-imx233], [Enable building support for IMX233 based SBCs]),
+      [build_imx233=$enableval], [build_imx233=yes])
+
+    AC_ARG_ENABLE([imx233_mini],
+      AS_HELP_STRING([--enable-imx233_mini], [Enable building support for STAMP_mini based SBCs]),
+      [build_imx233=$enableval], [build_imx233_mini=yes])
+
+    ;;
+
+  *)
+    build_ep93xx=no
+    build_at91rm9200=no
+    build_imx233=yes
+    build_imx233_mini=yes
+    ;;
+esac
+
+AC_ARG_ENABLE([gw16012],
+  AS_HELP_STRING([--enable-gw16012], [Enable building support for the Gateworks GW16012 JTAG Programmer]),
+  [build_gw16012=$enableval], [build_gw16012=no])
+
+AC_ARG_ENABLE([presto_libftdi],
+  AS_HELP_STRING([--enable-presto_libftdi], [Enable building support for ASIX Presto Programmer using the libftdi driver]),
+  [build_presto_libftdi=$enableval], [build_presto_libftdi=no])
+
+AC_ARG_ENABLE([presto_ftd2xx],
+  AS_HELP_STRING([--enable-presto_ftd2xx], [Enable building support for ASIX Presto Programmer using the FTD2XX driver]),
+  [build_presto_ftd2xx=$enableval], [build_presto_ftd2xx=no])
+
+AC_ARG_ENABLE([usbprog],
+  AS_HELP_STRING([--enable-usbprog], [Enable building support for the usbprog JTAG Programmer]),
+  [build_usbprog=$enableval], [build_usbprog=no])
+
+AC_ARG_ENABLE([oocd_trace],
+  AS_HELP_STRING([--enable-oocd_trace],
+  [Enable building support for some prototype OpenOCD+trace ETM capture hardware]),
+  [build_oocd_trace=$enableval], [build_oocd_trace=no])
+
+AC_ARG_ENABLE([jlink],
+  AS_HELP_STRING([--enable-jlink], [Enable building support for the Segger J-Link JTAG Programmer]),
+  [build_jlink=$enableval], [build_jlink=no])
+
+AC_ARG_ENABLE([vsllink],
+  AS_HELP_STRING([--enable-vsllink], [Enable building support for the Versaloon-Link JTAG Programmer]),
+  [build_vsllink=$enableval], [build_vsllink=no])
+
+AC_ARG_ENABLE([rlink],
+  AS_HELP_STRING([--enable-rlink], [Enable building support for the Raisonance RLink JTAG Programmer]),
+  [build_rlink=$enableval], [build_rlink=no])
+
+AC_ARG_ENABLE([ulink],
+  AS_HELP_STRING([--enable-ulink], [Enable building support for the Keil ULINK JTAG Programmer]),
+  [build_ulink=$enableval], [build_ulink=no])
+
+AC_ARG_ENABLE([arm-jtag-ew],
+  AS_HELP_STRING([--enable-arm-jtag-ew], [Enable building support for the Olimex ARM-JTAG-EW Programmer]),
+  [build_armjtagew=$enableval], [build_armjtagew=no])
+
+AC_ARG_ENABLE([buspirate],
+  AS_HELP_STRING([--enable-buspirate], [Enable building support for the Buspirate]),
+  [build_buspirate=$enableval], [build_buspirate=no])
+
+AC_ARG_ENABLE([stlink],
+  AS_HELP_STRING([--enable-stlink], [Enable building support for the ST-Link JTAG Programmer]),
+  [build_hladapter_stlink=$enableval], [build_hladapter_stlink=no])
+
+AC_ARG_ENABLE([ti-icdi],
+  AS_HELP_STRING([--enable-ti-icdi], [Enable building support for the TI ICDI JTAG Programmer]),
+  [build_hladapter_icdi=$enableval], [build_hladapter_icdi=no])
+
+AC_ARG_ENABLE([osbdm],
+  AS_HELP_STRING([--enable-osbdm], [Enable building support for the OSBDM (JTAG only) Programmer]),
+  [build_osbdm=$enableval], [build_osbdm=no])
+
+AC_ARG_ENABLE([opendous],
+  AS_HELP_STRING([--enable-opendous], [Enable building support for the estick/opendous JTAG Programmer]),
+  [build_opendous=$enableval], [build_opendous=no])
+
+AC_ARG_ENABLE([sysfsgpio],
+  AS_HELP_STRING([--enable-sysfsgpio], [Enable building support for programming driven via sysfs gpios.]),
+  [build_sysfsgpio=$enableval], [build_sysfsgpio=no])
+
+AC_ARG_ENABLE([minidriver_dummy],
+  AS_HELP_STRING([--enable-minidriver-dummy], [Enable the dummy minidriver.]),
+  [build_minidriver_dummy=$enableval], [build_minidriver_dummy=no])
+
+AC_ARG_ENABLE([internal-jimtcl],
+  AS_HELP_STRING([--disable-internal-jimtcl], [Disable building internal jimtcl]),
+  [use_internal_jimtcl=$enableval], [use_internal_jimtcl=yes])
+
+AC_ARG_ENABLE([libusb0],
+  AS_HELP_STRING([--enable-libusb0], [Use libusb-0.1 library for USB JTAG devices]),
+  [check_libusb0=$enableval], [check_libusb0=no])
+
+build_minidriver=no
+AC_MSG_CHECKING([whether to enable ZY1000 minidriver])
+if test $build_zy1000 = yes; then
+  if test $build_minidriver = yes; then
+    AC_MSG_ERROR([Multiple minidriver options have been enabled.])
+  fi
+  AC_DEFINE([HAVE_JTAG_MINIDRIVER_H], [1],
+      [Define to 1 if you have the <jtag_minidriver.h> header file.])
+  build_minidriver=yes
+fi
+AC_MSG_RESULT([$build_zy1000])
+
+AC_ARG_ENABLE([remote-bitbang],
+  AS_HELP_STRING([--enable-remote-bitbang], [Enable building support for the Remote Bitbang jtag driver]),
+  [build_remote_bitbang=$enableval], [build_remote_bitbang=no])
+
+AC_MSG_CHECKING([whether to enable dummy minidriver])
+if test $build_minidriver_dummy = yes; then
+  if test $build_minidriver = yes; then
+    AC_MSG_ERROR([Multiple minidriver options have been enabled.])
+  fi
+  build_minidriver=yes
+  AC_DEFINE([BUILD_MINIDRIVER_DUMMY], [1], [Use the dummy minidriver.])
+  AC_DEFINE([HAVE_JTAG_MINIDRIVER_H], [1],
+      [Define to 1 if you have the <jtag_minidriver.h> header file.])
+fi
+AC_MSG_RESULT([$build_minidriver_dummy])
+
+AC_MSG_CHECKING([whether standard drivers can be built])
+if test "$build_minidriver" = yes; then
+  AC_MSG_RESULT([no])
+  AC_MSG_WARN([Using the minidriver disables all other drivers.])
+  sleep 2
+else
+  AC_MSG_RESULT([yes])
+fi
+
+case "${host_cpu}" in
+  i?86|x86*)
+    ;;
+  *)
+    if test x$parport_use_ppdev = xno; then
+      AC_MSG_WARN([--disable-parport-ppdev is not supported by the host CPU])
+    fi
+    parport_use_ppdev=yes
+    ;;
+esac
+
+case $host in
+  *-cygwin*)
+    is_win32=yes
+    parport_use_ppdev=no
+
+    AC_COMPILE_IFELSE([AC_LANG_PROGRAM([], [[return __MINGW32__;]])],
+      [is_mingw=yes],[is_mingw=no])
+    if test $is_mingw = yes; then
+      AC_DEFINE([IS_MINGW], [1], [1 if building for MinGW.])
+      if test x$parport_use_giveio = xno; then
+        AC_MSG_WARN([--disable-parport-giveio is not supported by MinGW32 hosts])
+      fi
+      parport_use_giveio=yes
+      is_cygwin=no
+    else
+      is_cygwin=yes
+      AC_DEFINE([IS_CYGWIN], [1], [1 if building for Cygwin.])
+      # sys/io.h needed under cygwin for parport access
+      if test $build_parport = yes; then
+        AC_CHECK_HEADERS([sys/io.h],[],AC_MSG_ERROR([Please install the cygwin ioperm package]))
+      fi
+    fi
+
+    AC_DEFINE([IS_WIN32], [1], [1 if building for Win32.])
+    AC_DEFINE([IS_DARWIN], [0], [0 if not building for Darwin.])
+    ;;
+  *-mingw*)
+    is_mingw=yes
+    is_win32=yes
+    parport_use_ppdev=no
+
+    if test x$parport_use_giveio = xno; then
+      AC_MSG_WARN([--disable-parport-giveio is not supported by MinGW32 hosts])
+    fi
+    parport_use_giveio=yes
+
+    if test x$build_buspirate = xyes; then
+      AC_MSG_ERROR([buspirate currently not supported by MinGW32 hosts])
+    fi
+
+    CFLAGS="$CFLAGS -D__USE_MINGW_ANSI_STDIO"
+
+    AC_DEFINE([IS_MINGW], [1], [1 if building for MinGW.])
+    AC_DEFINE([IS_WIN32], [1], [1 if building for Win32.])
+    AC_DEFINE([IS_DARWIN], [0], [0 if not building for Darwin.])
+    ;;
+  *darwin*)
+    is_darwin=yes
+
+    if test x$parport_use_giveio = xyes; then
+      AC_MSG_WARN([--enable-parport-giveio cannot be used by Darwin hosts])
+    fi
+    parport_use_giveio=no
+
+    AC_DEFINE([IS_CYGWIN], [0], [0 if not building for Cygwin.])
+    AC_DEFINE([IS_WIN32], [0], [0 if not building for Win32.])
+    AC_DEFINE([IS_DARWIN], [1], [1 if building for Darwin.])
+    ;;
+  *)
+    if test x$parport_use_giveio = xyes; then
+      AC_MSG_WARN([--enable-parport-giveio cannot be used by ]$host[ hosts])
+    fi
+    parport_use_giveio=no
+    AC_DEFINE([IS_CYGWIN], [0], [0 if not building for Cygwin.])
+    AC_DEFINE([IS_WIN32], [0], [0 if not building for Win32.])
+    AC_DEFINE([IS_DARWIN], [0], [0 if not building for Darwin.])
+    ;;
+esac
+
+if test $build_parport = yes; then
+  build_bitbang=yes
+  AC_DEFINE([BUILD_PARPORT], [1], [1 if you want parport.])
+else
+  AC_DEFINE([BUILD_PARPORT], [0], [0 if you don't want parport.])
+fi
+
+if test $build_dummy = yes; then
+  build_bitbang=yes
+  AC_DEFINE([BUILD_DUMMY], [1], [1 if you want dummy driver.])
+else
+  AC_DEFINE([BUILD_DUMMY], [0], [0 if you don't want dummy driver.])
+fi
+
+if test $build_ep93xx = yes; then
+  build_bitbang=yes
+  AC_DEFINE([BUILD_EP93XX], [1], [1 if you want ep93xx.])
+else
+  AC_DEFINE([BUILD_EP93XX], [0], [0 if you don't want ep93xx.])
+fi
+
+if test $build_zy1000 = yes; then
+  AC_DEFINE([BUILD_ZY1000], [1], [1 if you want ZY1000.])
+else
+  AC_DEFINE([BUILD_ZY1000], [0], [0 if you don't want ZY1000.])
+fi
+
+if test $build_zy1000_master = yes; then
+  AC_DEFINE([BUILD_ZY1000_MASTER], [1], [1 if you want ZY1000 JTAG master registers.])
+else
+  AC_DEFINE([BUILD_ZY1000_MASTER], [0], [0 if you don't want ZY1000 JTAG master registers.])
+fi
+
+if test $build_at91rm9200 = yes; then
+  build_bitbang=yes
+  AC_DEFINE([BUILD_AT91RM9200], [1], [1 if you want at91rm9200.])
+else
+  AC_DEFINE([BUILD_AT91RM9200], [0], [0 if you don't want at91rm9200.])
+fi
+
+if test $build_imx233 = yes; then
+  build_bitbang=yes
+  AC_DEFINE([BUILD_IMX233], [1], [1 if you want imx233.])
+else
+  AC_DEFINE([BUILD_IMX233], [0], [0 if you don't want imx233.])
+fi
+
+if test $build_imx233_mini = yes; then
+  build_bitbang=yes
+  AC_DEFINE([BUILD_IMX233_MINI], [1], [1 if you want imx233_mini.])
+else
+  AC_DEFINE([BUILD_IMX233_MINI], [0], [0 if you don't want imx233_mini.])
+fi
+
+
+if test x$parport_use_ppdev = xyes; then
+  AC_DEFINE([PARPORT_USE_PPDEV], [1], [1 if you want parport to use ppdev.])
+else
+  AC_DEFINE([PARPORT_USE_PPDEV], [0], [0 if you don't want parport to use ppdev.])
+fi
+
+if test x$parport_use_giveio = xyes; then
+  AC_DEFINE([PARPORT_USE_GIVEIO], [1], [1 if you want parport to use giveio.])
+else
+  AC_DEFINE([PARPORT_USE_GIVEIO], [0], [0 if you don't want parport to use giveio.])
+fi
+
+if test $build_bitbang = yes; then
+  AC_DEFINE([BUILD_BITBANG], [1], [1 if you want a bitbang interface.])
+else
+  AC_DEFINE([BUILD_BITBANG], [0], [0 if you don't want a bitbang interface.])
+fi
+
+if test $build_ft2232_libftdi = yes; then
+  AC_DEFINE([BUILD_FT2232_LIBFTDI], [1], [1 if you want libftdi ft2232.])
+else
+  AC_DEFINE([BUILD_FT2232_LIBFTDI], [0], [0 if you don't want libftdi ft2232.])
+fi
+
+if test $build_ft2232_ftd2xx = yes; then
+  AC_DEFINE([BUILD_FT2232_FTD2XX], [1], [1 if you want ftd2xx ft2232.])
+else
+  AC_DEFINE([BUILD_FT2232_FTD2XX], [0], [0 if you don't want ftd2xx ft2232.])
+fi
+
+if test $build_ftdi = yes; then
+  AC_DEFINE([BUILD_FTDI], [1], [1 if you want ftdi.])
+else
+  AC_DEFINE([BUILD_FTDI], [0], [0 if you don't want ftdi.])
+fi
+
+if test $build_usb_blaster_libftdi = yes; then
+  build_bitbang=yes
+  AC_DEFINE([BUILD_USB_BLASTER_LIBFTDI], [1], [1 if you want libftdi usb_blaster.])
+else
+  AC_DEFINE([BUILD_USB_BLASTER_LIBFTDI], [0], [0 if you don't want libftdi usb_blaster.])
+fi
+
+if test $build_usb_blaster_ftd2xx = yes; then
+  build_bitbang=yes
+  AC_DEFINE([BUILD_USB_BLASTER_FTD2XX], [1], [1 if you want ftd2xx usb_blaster.])
+else
+  AC_DEFINE([BUILD_USB_BLASTER_FTD2XX], [0], [0 if you don't want ftd2xx usb_blaster.])
+fi
+
+if test $build_amtjtagaccel = yes; then
+  AC_DEFINE([BUILD_AMTJTAGACCEL], [1], [1 if you want the Amontec JTAG-Accelerator driver.])
+else
+  AC_DEFINE([BUILD_AMTJTAGACCEL], [0], [0 if you don't want the Amontec JTAG-Accelerator driver.])
+fi
+
+if test $build_gw16012 = yes; then
+  AC_DEFINE([BUILD_GW16012], [1], [1 if you want the Gateworks GW16012 driver.])
+else
+  AC_DEFINE([BUILD_GW16012], [0], [0 if you don't want the Gateworks GW16012 driver.])
+fi
+
+if test $build_presto_libftdi = yes; then
+  build_bitq=yes
+  AC_DEFINE([BUILD_PRESTO_LIBFTDI], [1], [1 if you want the ASIX PRESTO driver using libftdi.])
+else
+  AC_DEFINE([BUILD_PRESTO_LIBFTDI], [0], [0 if you don't want the ASIX PRESTO driver using libftdi.])
+fi
+
+if test $build_presto_ftd2xx = yes; then
+  build_bitq=yes
+  AC_DEFINE([BUILD_PRESTO_FTD2XX], [1], [1 if you want the ASIX PRESTO driver using FTD2XX.])
+else
+  AC_DEFINE([BUILD_PRESTO_FTD2XX], [0], [0 if you don't want the ASIX PRESTO driver using FTD2XX.])
+fi
+
+if test $build_bitq = yes; then
+  AC_DEFINE([BUILD_BITQ], [1], [1 if you want a bitq interface.])
+else
+  AC_DEFINE([BUILD_BITQ], [0], [0 if you don't want a bitq interface.])
+fi
+
+if test $build_usbprog = yes; then
+  AC_DEFINE([BUILD_USBPROG], [1], [1 if you want the usbprog JTAG driver.])
+else
+  AC_DEFINE([BUILD_USBPROG], [0], [0 if you don't want the usbprog JTAG driver.])
+fi
+
+if test $build_oocd_trace = yes; then
+  AC_DEFINE([BUILD_OOCD_TRACE], [1], [1 if you want the OpenOCD+trace ETM capture driver.])
+else
+  AC_DEFINE([BUILD_OOCD_TRACE], [0], [0 if you don't want the OpenOCD+trace ETM capture driver.])
+fi
+
+if test $build_jlink = yes; then
+  AC_DEFINE([BUILD_JLINK], [1], [1 if you want the J-Link JTAG driver.])
+else
+  AC_DEFINE([BUILD_JLINK], [0], [0 if you don't want the J-Link JTAG driver.])
+fi
+
+if test $build_vsllink = yes; then
+  AC_DEFINE([BUILD_VSLLINK], [1], [1 if you want the Versaloon-Link JTAG driver.])
+else
+  AC_DEFINE([BUILD_VSLLINK], [0], [0 if you don't want the Versaloon-Link JTAG driver.])
+fi
+
+if test $build_rlink = yes; then
+  AC_DEFINE([BUILD_RLINK], [1], [1 if you want the RLink JTAG driver.])
+else
+  AC_DEFINE([BUILD_RLINK], [0], [0 if you don't want the RLink JTAG driver.])
+fi
+
+if test $build_ulink = yes; then
+  AC_DEFINE([BUILD_ULINK], [1], [1 if you want the ULINK JTAG driver.])
+else
+  AC_DEFINE([BUILD_ULINK], [0], [0 if you don't want the ULINK JTAG driver.])
+fi
+
+if test $build_armjtagew = yes; then
+  AC_DEFINE([BUILD_ARMJTAGEW], [1], [1 if you want the ARM-JTAG-EW JTAG driver.])
+else
+  AC_DEFINE([BUILD_ARMJTAGEW], [0], [0 if you don't want the ARM-JTAG-EW JTAG driver.])
+fi
+
+if test $build_buspirate = yes; then
+  AC_DEFINE([BUILD_BUSPIRATE], [1], [1 if you want the Buspirate JTAG driver.])
+else
+  AC_DEFINE([BUILD_BUSPIRATE], [0], [0 if you don't want the Buspirate JTAG driver.])
+fi
+
+if test $build_hladapter_stlink = yes -o $build_hladapter_icdi = yes; then
+  AC_DEFINE([BUILD_HLADAPTER], [1], [1 if you want the High Level JTAG driver.])
+else
+  AC_DEFINE([BUILD_HLADAPTER], [0], [0 if you don't want the High Level JTAG driver.])
+fi
+
+if test $build_osbdm = yes; then
+  AC_DEFINE([BUILD_OSBDM], [1], [1 if you want the OSBDM driver.])
+else
+  AC_DEFINE([BUILD_OSBDM], [0], [0 if you don't want the OSBDM driver.])
+fi
+
+if test $build_opendous = yes; then
+  AC_DEFINE([BUILD_OPENDOUS], [1], [1 if you want the estick/opendous JTAG driver.])
+else
+  AC_DEFINE([BUILD_OPENDOUS], [0], [0 if you don't want the estick/opendous JTAG driver.])
+fi
+
+if test "$use_internal_jimtcl" = yes; then
+  if test -f "$srcdir/jimtcl/configure.ac"; then
+    AX_CONFIG_SUBDIR_OPTION([jimtcl], [--disable-install-jim])
+  else
+    AC_MSG_ERROR([jimtcl not found, run git submodule init and git submodule update.])
+  fi
+fi
+
+if test $build_remote_bitbang = yes; then
+  build_bitbang=yes
+  AC_DEFINE([BUILD_REMOTE_BITBANG], [1], [1 if you want the Remote Bitbang JTAG driver.])
+else
+  AC_DEFINE([BUILD_REMOTE_BITBANG], [0], [0 if you don't want the Remote Bitbang JTAG driver.])
+fi
+
+if test $build_sysfsgpio = yes; then
+  build_bitbang=yes
+  AC_DEFINE([BUILD_SYSFSGPIO], [1], [1 if you want the SysfsGPIO driver.])
+else
+  AC_DEFINE([BUILD_SYSFSGPIO], [0], [0 if you don't want SysfsGPIO driver.])
+fi
+#-- Deal with MingW/Cygwin FTD2XX issues
+
+if test $is_win32 = yes; then
+if test "${with_ftd2xx_linux_tardir+set}" = set
+then
+  AC_MSG_ERROR([The option: with_ftd2xx_linux_tardir is for LINUX only.])
+fi
+
+if test $build_ft2232_ftd2xx = yes -o $build_presto_ftd2xx = yes -o $build_usb_blaster_ftd2xx = yes ; then
+  AC_MSG_CHECKING([for ftd2xx.lib exists (win32)])
+
+  # if we are given a zipdir...
+  if test "${with_ftd2xx_win32_zipdir+set}" = set
+  then
+    # Set the CFLAGS for "ftd2xx.h"
+    f=$with_ftd2xx_win32_zipdir/ftd2xx.h
+    if test ! -f $f ; then
+      AC_MSG_ERROR([File: $f cannot be found])
+    fi
+    CFLAGS="$CFLAGS -I$with_ftd2xx_win32_zipdir"
+
+    # And calculate the LDFLAGS for the machine
+    case "$host_cpu" in
+    i?86|x86_32)
+      LDFLAGS="$LDFLAGS -L$with_ftd2xx_win32_zipdir/i386"
+      LIBS="$LIBS -lftd2xx"
+      f=$with_ftd2xx_win32_zipdir/i386/ftd2xx.lib
+      ;;
+    amd64|x86_64)
+      LDFLAGS="$LDFLAGS -L$with_ftd2xx_win32_zipdir/amd64"
+      LIBS="$LIBS -lftd2xx"
+      f=$with_ftd2xx_win32_zipdir/amd64/ftd2xx.lib
+      ;;
+    *)
+      AC_MSG_ERROR([Unknown Win32 host cpu: $host_cpu])
+      ;;
+    esac
+    if test ! -f $f ; then
+         AC_MSG_ERROR([Library: $f not found])
+    fi
+  else
+    LIBS="$LIBS -lftd2xx"
+    AC_MSG_WARN([ASSUMPTION: The (win32) FTDICHIP.COM files: ftd2xx.h and ftd2xx.lib are in a proper place])
+  fi
+fi
+fi # win32
+
+if test $is_darwin = yes ; then
+if test "${with_ftd2xx_win32_zipdir+set}" = set
+then
+   AC_MSG_ERROR([The option: --with-ftd2xx-win32-zipdir is for win32 only])
+fi
+if test "${with_ftd2xx_linux_tardir+set}" = set
+then
+   AC_MSG_ERROR([The option: with_ftd2xx_linux_tardir is for LINUX only.])
+fi
+
+if test $build_ft2232_ftd2xx = yes -o $build_presto_ftd2xx = yes -o $build_usb_blaster_ftd2xx = yes ; then
+   AC_MSG_CHECKING([for libftd2xx.a (darwin)])
+
+   if test ! -f /usr/local/include/ftd2xx.h ; then
+      AC_MSG_ERROR([ftd2xx library from FTDICHIP.com seems to be missing, cannot find: /usr/local/include/ftd2xx.h])
+   fi
+
+   CFLAGS="$CFLAGS -I/usr/local/include"
+   LDFLAGS="$LDFLAGS -L/usr/local/lib"
+   LIBS="$LIBS -lftd2xx"
+   AC_MSG_RESULT([-L/usr/local/lib -lftd2xx])
+fi
+fi # darwin
+
+if test $is_win32 = no && test $is_darwin = no ; then
+
+if test "${with_ftd2xx_win32_zipdir+set}" = set
+then
+   AC_MSG_ERROR([The option: --with-ftd2xx-win32-zipdir is for win32 only])
+fi
+
+if test $build_ft2232_ftd2xx = yes -o $build_presto_ftd2xx = yes -o $build_usb_blaster_ftd2xx = yes ; then
+   # Must be linux
+   if test $host_os != linux-gnu && test $host_os != linux ; then
+      AC_MSG_ERROR([The (linux) ftd2xx library from FTDICHIP.com is linux only. Try --enable-ft2232-libftdi instead])
+  fi
+  # Are we given a TAR directory?
+  if test "${with_ftd2xx_linux_tardir+set}" = set
+  then
+    AC_MSG_CHECKING([uninstalled ftd2xx distribution])
+    # The .H file is simple..
+    FTD2XX_H=$with_ftd2xx_linux_tardir/ftd2xx.h
+    if test ! -f "${FTD2XX_H}"; then
+    AC_MSG_ERROR([Option: --with-ftd2xx-linux-tardir appears wrong, cannot find: ${FTD2XX_H}])
+    fi
+    CFLAGS="$CFLAGS -I$with_ftd2xx_linux_tardir"
+    if test $with_ftd2xx_lib = shared; then
+       FTD2XX_LDFLAGS="-L$with_ftd2xx_linux_tardir"
+       FTD2XX_LIB="-lftd2xx"
+    else
+      # Test #1 - v1.0.x
+      case "$host_cpu" in
+      i?86|x86_32)
+              dir=build/i386;;
+      amd64|x86_64)
+              dir=build/x86_64;;
+      *)
+              dir=none;;
+      esac
+      if test -f "$with_ftd2xx_linux_tardir/$dir/libftd2xx.a"; then
+          FTD2XX_LDFLAGS="-L$with_ftd2xx_linux_tardir/$dir"
+          # Also needs -lrt
+          FTD2XX_LIB="-lftd2xx -lrt"
+      else
+        # Test Number2.
+        # Grr.. perhaps it exists as a version number?
+        FTD2XX_LIB="$with_ftd2xx_linux_tardir/static_lib/libftd2xx.a.*.*.*"
+        count=`ls ${FTD2XX_LIB} | wc -l`
+        if test $count -gt 1 ; then
+          AC_MSG_ERROR([Multiple libftd2xx.a files found in: $with_ftd2xx_linux_tardir/static_lib sorry cannot handle this yet])
+        fi
+        if test $count -ne 1 ; then
+          AC_MSG_ERROR([Not found: $f, option: --with-ftd2xx-linux-tardir appears to be wrong])
+        fi
+        # Because the "-l" rules do not understand version numbers...
+        # we will just stuff the absolute path onto the LIBS variable
+        FTD2XX_LIB="`ls ${FTD2XX_LIB}` -lpthread"
+        FTD2XX_LDFLAGS=""
+      fi
+    fi
+    LDFLAGS="${LDFLAGS} ${FTD2XX_LDFLAGS}"
+    LIBS="${FTD2XX_LIB} ${LIBS}"
+    AC_MSG_RESULT([${FTD2XX_LDFLAGS} ${FTD2XX_LIB}])
+  else
+    AC_CHECK_HEADER([ftd2xx.h],[],[
+        AC_MSG_ERROR([You seem to be missing the FTD2xx driver header file.])
+      ])
+    AC_SEARCH_LIBS([FT_GetLibraryVersion],[ftd2xx],,[
+        AC_MSG_ERROR([You appear to be missing the FTD2xx driver library.])
+      ],[])
+  fi
+fi
+fi # linux
+
+if test $build_ft2232_ftd2xx = yes -o $build_presto_ftd2xx = yes -o $build_usb_blaster_ftd2xx = yes ; then
+
+# Before we go any further - make sure we can *BUILD* and *RUN*
+# a simple app with the "ftd2xx.lib" file - in what ever form we where given
+# We should be able to compile, link and run this test program now
+AC_MSG_CHECKING([whether ftd2xx library works])
+
+#
+# Save the LDFLAGS for later..
+LDFLAGS_SAVE=$LDFLAGS
+CFLAGS_SAVE=$CFLAGS
+_LDFLAGS=`eval echo $LDFLAGS`
+_CFLAGS=`eval echo $CFLAGS`
+LDFLAGS=$_LDFLAGS
+CFLAGS=$_CFLAGS
+
+AC_RUN_IFELSE([AC_LANG_PROGRAM([[
+#include "confdefs.h"
+#if IS_WIN32
+#include "windows.h"
+#endif
+#include <stdio.h>
+#include <ftd2xx.h>
+  ]], [[
+  DWORD x;
+  FT_GetLibraryVersion( &x );
+  ]])], [
+    AC_MSG_RESULT([Success!])
+  ], [
+    AC_MSG_ERROR([Cannot build & run test program using ftd2xx.lib])
+  ], [
+    AC_MSG_RESULT([Skipping as we are cross-compiling])
+  ])
+
+AC_MSG_CHECKING([for ftd2xx highspeed device support])
+AC_COMPILE_IFELSE([AC_LANG_PROGRAM([[
+#include "confdefs.h"
+#if IS_WIN32
+#include "windows.h"
+#endif
+#include <stdio.h>
+#include <ftd2xx.h>
+
+DWORD x = FT_DEVICE_4232H;
+    ]], [])], [
+      AC_DEFINE([BUILD_FT2232_HIGHSPEED], [1],
+        [Support FT2232H/FT4232HS with FTD2XX or libftdi.])
+      build_ft2232_highspeed=yes
+    ], [
+      build_ft2232_highspeed=no
+    ])
+  AC_MSG_RESULT([$build_ft2232_highspeed])
+
+  if test $build_ft2232_highspeed = no; then
+    AC_MSG_WARN([You need a newer FTD2XX driver (version 2.04.16 or later).])
+  fi
+
+AC_MSG_CHECKING([for ftd2xx FT232H device support])
+AC_COMPILE_IFELSE([AC_LANG_PROGRAM([[
+#include "confdefs.h"
+#if IS_WIN32
+#include "windows.h"
+#endif
+#include <stdio.h>
+#include <ftd2xx.h>
+
+DWORD x = FT_DEVICE_232H;
+    ]], [])], [
+      AC_DEFINE([HAS_ENUM_FT232H], [1],
+        [Support FT232H with FTD2XX or libftdi.])
+      has_enum_ft232h=yes
+    ], [
+      has_enum_ft232h=no
+    ])
+  AC_MSG_RESULT([$has_enum_ft232h])
+
+  if test $has_enum_ft232h = no; then
+    AC_MSG_WARN([You need a newer FTD2XX driver (version 2.08.12 or later).])
+  fi
+
+LDFLAGS=$LDFLAGS_SAVE
+CFLAGS=$CFLAGS_SAVE
+fi
+
+if test $build_ft2232_libftdi = yes ; then
+  # We assume: the package is preinstalled in the proper place
+  # these present as 2 libraries..
+  LIBS="$LIBS -lftdi -lusb"
+  #
+  # Try to build a small program.
+  AC_MSG_CHECKING([Build & Link with libftdi...])
+
+  LDFLAGS_SAVE=$LDFLAGS
+  CFLAGS_SAVE=$CFLAGS
+  _LDFLAGS=`eval echo $LDFLAGS`
+  _CFLAGS=`eval echo $CFLAGS`
+  LDFLAGS=$_LDFLAGS
+  CFLAGS=$_CFLAGS
+
+  AC_RUN_IFELSE([AC_LANG_PROGRAM([[
+#include <stdio.h>
+#include <ftdi.h>
+  ]], [[
+  struct ftdi_context *p;
+  p = ftdi_new();
+  if( p != NULL ){
+      return 0;
+  } else {
+      fprintf( stderr, "calling ftdi_new() failed\n");
+      return 1;
+        }
+    ]])], [
+      AC_MSG_RESULT([Success])
+    ], [
+      AC_MSG_ERROR([Cannot build & run test program using libftdi])
+    ], [
+      AC_MSG_RESULT([Skipping as we are cross-compiling])
+    ])
+
+AC_MSG_CHECKING([for libftdi highspeed device support])
+AC_COMPILE_IFELSE([AC_LANG_PROGRAM([[
+#include <stdio.h>
+#include <ftdi.h>
+  ]], [[
+enum ftdi_chip_type x = TYPE_2232H;
+    ]])], [
+      AC_DEFINE([BUILD_FT2232_HIGHSPEED], [1],
+        [Support FT2232H/FT4232HS with FTD2XX or libftdi.])
+      build_ft2232_highspeed=yes
+    ], [
+      build_ft2232_highspeed=no
+    ])
+    AC_MSG_RESULT([$build_ft2232_highspeed])
+
+    if test $build_ft2232_highspeed = no; then
+      AC_MSG_WARN([You need a newer libftdi version (0.16 or later).])
+    fi
+
+AC_MSG_CHECKING([for libftdi FT232H device support])
+AC_COMPILE_IFELSE([AC_LANG_PROGRAM([[
+#include <stdio.h>
+#include <ftdi.h>
+  ]], [[
+enum ftdi_chip_type x = TYPE_232H;
+    ]])], [
+      AC_DEFINE([HAS_ENUM_FT232H], [1],
+        [Support FT232H with FTD2XX or libftdi.])
+      has_enum_ft232h=yes
+    ], [
+      has_enum_ft232h=no
+    ])
+    AC_MSG_RESULT([$has_enum_ft232h])
+
+    if test $has_enum_ft232h = no; then
+      AC_MSG_WARN([You need a newer libftdi version (0.20 or later).])
+    fi
+
+  # Restore the 'unexpanded ldflags'
+  LDFLAGS=$LDFLAGS_SAVE
+  CFLAGS=$CFLAGS_SAVE
+fi
+
+# check for usb.h when a driver will require it
+build_usb=no
+if test $build_vsllink = yes -o $build_usbprog = yes -o \
+  $build_rlink = yes -o $build_ulink = yes -o $build_armjtagew = yes
+then
+  build_usb=yes
+fi
+
+# Check for libusb1 ported drivers.
+build_usb_ng=no
+if test $build_jlink = yes -o $build_hladapter_stlink = yes -o $build_osbdm = yes -o \
+  $build_opendous = yes -o $build_ftdi = yes -o $build_hladapter_icdi = yes
+then
+  build_usb_ng=yes
+fi
+
+# check for libusb library if necessary
+use_libusb0=no
+use_libusb1=no
+if test $build_usb = yes -o $build_usb_ng = yes; then
+  if test $check_libusb0 = no -a $build_usb_ng = yes; then
+	AC_CHECK_HEADER([libusb-1.0/libusb.h],
+			[AC_DEFINE(HAVE_LIBUSB1, 1, [Define if you have libusb-1.0]) check_libusb0=no use_libusb1=yes ],
+			[ check_libusb0=yes use_libusb1=no ])
+  fi
+
+  if test $check_libusb0 = yes -o $build_usb = yes; then
+	AC_CHECK_HEADERS([usb.h], [use_libusb0=yes],
+			[AC_MSG_ERROR([libusb or libusb-1.0 are required to build some OpenOCD driver(s)])])
+  fi
+fi
+
+AM_CONDITIONAL([RELEASE], [test $build_release = yes])
+AM_CONDITIONAL([PARPORT], [test $build_parport = yes])
+AM_CONDITIONAL([DUMMY], [test $build_dummy = yes])
+AM_CONDITIONAL([GIVEIO], [test x$parport_use_giveio = xyes])
+AM_CONDITIONAL([EP93XX], [test $build_ep93xx = yes])
+AM_CONDITIONAL([ZY1000], [test $build_zy1000 = yes])
+AM_CONDITIONAL([ZY1000_MASTER], [test $build_zy1000_master = yes])
+AM_CONDITIONAL([IOUTIL], [test $build_ioutil = yes])
+AM_CONDITIONAL([AT91RM9200], [test $build_at91rm9200 = yes])
+AM_CONDITIONAL([IMX233], [test $build_imx233 = yes])
+AM_CONDITIONAL([IMX233_MINI], [test $build_imx233_mini = yes])
+AM_CONDITIONAL([BITBANG], [test $build_bitbang = yes])
+AM_CONDITIONAL([FT2232_LIBFTDI], [test $build_ft2232_libftdi = yes])
+AM_CONDITIONAL([FT2232_DRIVER], [test $build_ft2232_ftd2xx = yes -o $build_ft2232_libftdi = yes])
+AM_CONDITIONAL([FTDI_DRIVER], [test $build_ftdi = yes])
+AM_CONDITIONAL([USB_BLASTER_LIBFTDI], [test $build_usb_blaster_libftdi = yes])
+AM_CONDITIONAL([USB_BLASTER_DRIVER], [test $build_usb_blaster_ftd2xx = yes -o $build_usb_blaster_libftdi = yes])
+AM_CONDITIONAL([AMTJTAGACCEL], [test $build_amtjtagaccel = yes])
+AM_CONDITIONAL([GW16012], [test $build_gw16012 = yes])
+AM_CONDITIONAL([PRESTO_LIBFTDI], [test $build_presto_libftdi = yes])
+AM_CONDITIONAL([PRESTO_DRIVER], [test $build_presto_ftd2xx = yes -o $build_presto_libftdi = yes])
+AM_CONDITIONAL([USBPROG], [test $build_usbprog = yes])
+AM_CONDITIONAL([OOCD_TRACE], [test $build_oocd_trace = yes])
+AM_CONDITIONAL([JLINK], [test $build_jlink = yes])
+AM_CONDITIONAL([VSLLINK], [test $build_vsllink = yes])
+AM_CONDITIONAL([RLINK], [test $build_rlink = yes])
+AM_CONDITIONAL([ULINK], [test $build_ulink = yes])
+AM_CONDITIONAL([ARMJTAGEW], [test $build_armjtagew = yes])
+AM_CONDITIONAL([REMOTE_BITBANG], [test $build_remote_bitbang = yes])
+AM_CONDITIONAL([BUSPIRATE], [test $build_buspirate = yes])
+AM_CONDITIONAL([HLADAPTER], [test $build_hladapter_stlink = yes -o $build_hladapter_icdi = yes])
+AM_CONDITIONAL([OSBDM], [test $build_osbdm = yes])
+AM_CONDITIONAL([OPENDOUS], [test $build_opendous = yes])
+AM_CONDITIONAL([SYSFSGPIO], [test $build_sysfsgpio = yes])
+AM_CONDITIONAL([USB], [test $build_usb = yes])
+AM_CONDITIONAL([USB_NG], [test $build_usb_ng = yes])
+AM_CONDITIONAL([USE_LIBUSB0], [test $use_libusb0 = yes])
+AM_CONDITIONAL([USE_LIBUSB1], [test $use_libusb1 = yes])
+AM_CONDITIONAL([IS_CYGWIN], [test $is_cygwin = yes])
+AM_CONDITIONAL([IS_MINGW], [test $is_mingw = ye]s)
+AM_CONDITIONAL([IS_WIN32], [test $is_win32 = ye]s)
+AM_CONDITIONAL([IS_DARWIN], [test $is_darwin = ye]s)
+AM_CONDITIONAL([BITQ], [test $build_bitq = yes])
+
+AM_CONDITIONAL([MINIDRIVER], [test $build_minidriver = ye]s)
+AM_CONDITIONAL([MINIDRIVER_DUMMY], [test $build_minidriver_dummy = yes])
+
+AM_CONDITIONAL([INTERNAL_JIMTCL], [test $use_internal_jimtcl = yes])
+
+# Look for environ alternatives.  Possibility #1: is environ in unistd.h or stdlib.h?
+AC_MSG_CHECKING([for environ in unistd.h and stdlib.h])
+AC_COMPILE_IFELSE([AC_LANG_PROGRAM([[
+#define _GNU_SOURCE
+#include <unistd.h>
+#include <stdlib.h>
+  ]], [[char **ep = environ;]]
+  )], [
+    AC_MSG_RESULT([yes])
+    has_environ=yes
+  ], [
+    AC_MSG_RESULT([no])
+
+    # Possibility #2: can environ be found in an available library?
+    AC_MSG_CHECKING([for extern environ])
+    AC_LINK_IFELSE([AC_LANG_PROGRAM([[
+    extern char **environ;
+    ]], [[char **ep = environ;]]
+      )], [
+        AC_DEFINE(NEED_ENVIRON_EXTERN, [1], [Must declare 'environ' to use it.])
+        has_environ=yes
+      ], [
+        has_environ=no
+      ])
+    AC_MSG_RESULT([${has_environ}])
+  ])
+
+if test "${has_environ}" != "yes" ; then
+  AC_MSG_FAILURE([Could not find 'environ' in unistd.h or available libraries.])
+fi
+
+AC_DEFINE([_GNU_SOURCE],[1],[Use GNU C library extensions (e.g. stdndup).])
+
+# set default gcc warnings
+GCC_WARNINGS="-Wall -Wstrict-prototypes -Wformat-security -Wshadow"
+if test "${gcc_wextra}" = yes; then
+  GCC_WARNINGS="${GCC_WARNINGS} -Wextra -Wno-unused-parameter"
+  GCC_WARNINGS="${GCC_WARNINGS} -Wbad-function-cast"
+  GCC_WARNINGS="${GCC_WARNINGS} -Wcast-align"
+  GCC_WARNINGS="${GCC_WARNINGS} -Wredundant-decls"
+fi
+if test "${gcc_werror}" = yes; then
+  GCC_WARNINGS="${GCC_WARNINGS} -Werror"
+fi
+
+# overide default gcc cflags
+if test $gcc_warnings = yes; then
+  CFLAGS="$CFLAGS $GCC_WARNINGS"
+fi
+
+# Setup for compiling build tools
+AC_MSG_CHECKING([for a C compiler for build tools])
+if test $cross_compiling = yes; then
+  AC_CHECK_PROGS(CC_FOR_BUILD, gcc cc)
+  CFLAGS_FOR_BUILD="-g -O2 $GCC_WARNINGS"
+else
+  CC_FOR_BUILD=$CC
+  CFLAGS_FOR_BUILD=$CFLAGS
+fi
+
+AC_MSG_RESULT([$CC_FOR_BUILD])
+AC_SUBST([CC_FOR_BUILD])
+AC_SUBST([CFLAGS_FOR_BUILD])
+
+AC_MSG_CHECKING([for suffix of executable build tools])
+if test $cross_compiling = yes; then
+  cat >conftest.c <<\_______EOF
+int main ()
+{
+  exit (0);
+}
+_______EOF
+  for i in .exe ""; do
+    compile="$CC_FOR_BUILD conftest.c -o conftest$i"
+    if AC_TRY_EVAL(compile); then
+      if (./conftest) 2>&AC_FD_CC; then
+        EXEEXT_FOR_BUILD=$i
+        break
+      fi
+    fi
+  done
+  rm -f conftest*
+  if test "${EXEEXT_FOR_BUILD+set}" != set; then
+    AC_MSG_ERROR([Cannot determine suffix of executable build tools])
+  fi
+else
+  EXEEXT_FOR_BUILD=$EXEEXT
+fi
+AC_MSG_RESULT([$EXEEXT_FOR_BUILD])
+AC_SUBST([EXEEXT_FOR_BUILD])
+
+AC_CONFIG_FILES([
+  Makefile
+  src/Makefile
+  src/helper/Makefile
+  src/jtag/Makefile
+  src/jtag/drivers/Makefile
+  src/jtag/hla/Makefile
+  src/transport/Makefile
+  src/xsvf/Makefile
+  src/svf/Makefile
+  src/target/Makefile
+  src/rtos/Makefile
+  src/server/Makefile
+  src/flash/Makefile
+  src/flash/nor/Makefile
+  src/flash/nand/Makefile
+  src/pld/Makefile
+  doc/Makefile
+])
+AC_OUTPUT
diff -Naur openocd-0.7.0/jimtcl/auto.def openocd-0.7.0_stamp/jimtcl/auto.def
--- openocd-0.7.0/jimtcl/auto.def	2013-04-19 21:57:39.000000000 +0000
+++ openocd-0.7.0_stamp/jimtcl/auto.def	2013-05-23 13:52:21.370000164 +0000
@@ -181,12 +181,12 @@
     msg-result "Enabling references"
     define JIM_REFERENCES
 }
-if {[opt-bool shared with-jim-shared]} {
-    msg-result "Building shared library"
-} else {
+#if {[opt-bool shared with-jim-shared]} {
+#    msg-result "Building shared library"
+#} else {
     msg-result "Building static library"
     define JIM_STATICLIB
-}
+#}
 define JIM_INSTALL [opt-bool install-jim]
 
 # Attributes of the extensions
diff -Naur openocd-0.7.0/src/flash/nor/at91sam3.c openocd-0.7.0_stamp/src/flash/nor/at91sam3.c
--- openocd-0.7.0/src/flash/nor/at91sam3.c	2013-04-28 07:42:16.000000000 +0000
+++ openocd-0.7.0_stamp/src/flash/nor/at91sam3.c	2013-05-18 17:27:23.000000000 +0000
@@ -998,6 +998,55 @@
 	},
 
 	{
+		.chipid_cidr    = 0x29380360,
+		.name           = "at91sam3n0aa",
+		.total_flash_size     = 32 * 1024,
+		.total_sram_size      = 8 * 1024,
+		.n_gpnvms       = 3,
+		.n_banks        = 1,
+
+		/* System boots at address 0x0 */
+		/* gpnvm[1] = selects boot code */
+		/*     if gpnvm[1] == 0 */
+		/*         boot is via "SAMBA" (rom) */
+		/*     else */
+		/*         boot is via FLASH */
+		/*         Selection is via gpnvm[2] */
+		/*     endif */
+		/*  */
+		/* NOTE: banks 0 & 1 switch places */
+		/*     if gpnvm[2] == 0 */
+		/*         Bank0 is the boot rom */
+		/*      else */
+		/*         Bank1 is the boot rom */
+		/*      endif */
+/*		.bank[0] = { */
+		{
+			{
+				.probed = 0,
+				.pChip  = NULL,
+				.pBank  = NULL,
+				.bank_number = 0,
+				.base_address = FLASH_BANK_BASE_N,
+				.controller_address = 0x400e0A00,
+				.flash_wait_states = 6,	/* workaround silicon bug */
+				.present = 1,
+				.size_bytes = 32 * 1024,
+				.nsectors   = 2,
+				.sector_size = 16384,
+				.page_size   = 256,
+			},
+
+/*		.bank[1] = { */
+			{
+				.present = 0,
+				.probed = 0,
+				.bank_number = 1,
+			},
+		},
+	},
+
+	{
 		.chipid_cidr    = 0x29340960,
 		.name           = "at91sam3n4a",
 		.total_flash_size     = 256 * 1024,
diff -Naur openocd-0.7.0/src/flash/nor/efm32.c openocd-0.7.0_stamp/src/flash/nor/efm32.c
--- openocd-0.7.0/src/flash/nor/efm32.c	2013-04-28 07:42:16.000000000 +0000
+++ openocd-0.7.0_stamp/src/flash/nor/efm32.c	2013-05-23 12:00:43.349998438 +0000
@@ -85,7 +85,7 @@
 
 struct efm32x_flash_bank {
 	int probed;
-	uint8_t lb_page[LOCKBITS_PAGE_SZ];
+        uint32_t lb_page[LOCKBITS_PAGE_SZ/4];
 };
 
 struct efm32_info {
@@ -370,7 +370,7 @@
 	data_size = bank->num_sectors / 8; /* number of data bytes */
 	data_size /= 4; /* ...and data dwords */
 
-	ptr = (uint32_t *)efm32x_info->lb_page;
+	ptr = efm32x_info->lb_page;
 
 	for (i = 0; i < data_size; i++, ptr++) {
 		ret = target_read_u32(target, EFM32_MSC_LOCK_BITS+i*4, ptr);
@@ -383,7 +383,7 @@
 	/* also, read ULW, DLW and MLW */
 
 	/* ULW, word 126 */
-	ptr = ((uint32_t *)efm32x_info->lb_page) + 126;
+	ptr = efm32x_info->lb_page + 126;
 	ret = target_read_u32(target, EFM32_MSC_LOCK_BITS+126*4, ptr);
 	if (ERROR_OK != ret) {
 		LOG_ERROR("Failed to read ULW");
@@ -391,7 +391,7 @@
 	}
 
 	/* DLW, word 127 */
-	ptr = ((uint32_t *)efm32x_info->lb_page) + 127;
+	ptr = efm32x_info->lb_page + 127;
 	ret = target_read_u32(target, EFM32_MSC_LOCK_BITS+127*4, ptr);
 	if (ERROR_OK != ret) {
 		LOG_ERROR("Failed to read DLW");
@@ -400,7 +400,7 @@
 
 	/* MLW, word 125, present in GG and LG */
 	ptr = ((uint32_t *)efm32x_info->lb_page) + 125;
-	ret = target_read_u32(target, EFM32_MSC_LOCK_BITS+125*4, ptr);
+	ptr = efm32x_info->lb_page + 125;
 	if (ERROR_OK != ret) {
 		LOG_ERROR("Failed to read MLW");
 		return ret;
@@ -420,14 +420,14 @@
 		return ret;
 	}
 
-	return efm32x_write(bank, efm32x_info->lb_page, EFM32_MSC_LOCK_BITS,
+	return efm32x_write(bank, (uint8_t *)efm32x_info->lb_page, EFM32_MSC_LOCK_BITS,
 		LOCKBITS_PAGE_SZ);
 }
 
 static int efm32x_get_page_lock(struct flash_bank *bank, size_t page)
 {
 	struct efm32x_flash_bank *efm32x_info = bank->driver_priv;
-	uint32_t dw = ((uint32_t *)efm32x_info->lb_page)[page >> 5];
+	uint32_t dw = efm32x_info->lb_page[page >> 5];
 	uint32_t mask = 0;
 
 	mask = 1 << (page & 0x1f);
@@ -438,7 +438,7 @@
 static int efm32x_set_page_lock(struct flash_bank *bank, size_t page, int set)
 {
 	struct efm32x_flash_bank *efm32x_info = bank->driver_priv;
-	uint32_t *dw = &((uint32_t *)efm32x_info->lb_page)[page >> 5];
+	uint32_t *dw = &efm32x_info->lb_page[page >> 5];
 	uint32_t mask = 0;
 
 	mask = 1 << (page & 0x1f);
diff -Naur openocd-0.7.0/src/jtag/drivers/Makefile.am openocd-0.7.0_stamp/src/jtag/drivers/Makefile.am
--- openocd-0.7.0/src/jtag/drivers/Makefile.am	2013-04-19 21:54:16.000000000 +0000
+++ openocd-0.7.0_stamp/src/jtag/drivers/Makefile.am	2013-05-17 02:14:58.000000000 +0000
@@ -58,6 +58,12 @@
 if AT91RM9200
 DRIVERFILES += at91rm9200.c
 endif
+if IMX233
+DRIVERFILES += imx233.c
+endif
+if IMX233_MINI
+DRIVERFILES += imx233_mini.c
+endif
 if GW16012
 DRIVERFILES += gw16012.c
 endif
diff -Naur openocd-0.7.0/src/jtag/drivers/imx233.c openocd-0.7.0_stamp/src/jtag/drivers/imx233.c
--- openocd-0.7.0/src/jtag/drivers/imx233.c	1970-01-01 00:00:00.000000000 +0000
+++ openocd-0.7.0_stamp/src/jtag/drivers/imx233.c	2013-05-17 02:05:47.000000000 +0000
@@ -0,0 +1,338 @@
+/***************************************************************************
+ *   Copyright (C) 2006 by Anders Larsen                                   *
+ *   al@alarsen.net                                                        *
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ *   This program is distributed in the hope that it will be useful,       *
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
+ *   GNU General Public License for more details.                          *
+ *                                                                         *
+ *   You should have received a copy of the GNU General Public License     *
+ *   along with this program; if not, write to the                         *
+ *   Free Software Foundation, Inc.,                                       *
+ *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
+ ***************************************************************************/
+#ifdef HAVE_CONFIG_H
+#include "config.h"
+#endif
+
+#include <jtag/interface.h>
+#include "bitbang.h"
+
+#include <sys/mman.h>
+
+
+/* AT91RM9200 */
+#define IMX233_BASE_SYS	(0x80018000)
+
+/* GPIO assignment (MUX_REG)*/
+
+
+#define PIO_CTRL	(0)		/* PIO enable */
+#define PIO_MUXSEL	(0x100)		/* output enable */
+#define PIO_DRIVE	(0x200)		/* output disable */
+#define PIO_PULL	(0x400)		/* set output data */
+#define PIO_DOUT	(0x500)		/* clear output data */
+#define PIO_DIN 	(0x600)		/* pin data status */
+#define PIO_DOE 	(0x700)		/* pull-up enable */
+#define PIO_PIN2IRQ 	(0x800)		/* pull-up enable */
+#define PIO_IRQEN 	(0x900)		/* pull-up enable */
+#define PIO_IRLEV 	(0xa00)		/* pull-up enable */
+#define PIO_POL 	(0xb00)		/* pull-up enable */
+#define PIO_IRQSTAT 	(0xc00)		/* pull-up enable */
+
+#define SET             (0x4)
+#define CLR             (0x8)
+#define TOG             (0xC)
+
+
+#define PIO0	(0*4)  //0x00
+#define PIO1	(4*4)  //0x10
+#define PIO2	(8*4)  //0x20
+#define PIO3	(12*4) //0x30
+
+
+
+#define NC	(0)			/* not connected */
+#define P0	(1 << 0)
+#define P1	(1 << 1)
+#define P2	(1 << 2)
+#define P3	(1 << 3)
+#define P4	(1 << 4)
+#define P5	(1 << 5)
+#define P6	(1 << 6)
+#define P7	(1 << 7)
+#define P8	(1 << 8)
+#define P9	(1 << 9)
+#define P10	(1 << 10)
+#define P11	(1 << 11)
+#define P12	(1 << 12)
+#define P13	(1 << 13)
+#define P14	(1 << 14)
+#define P15	(1 << 15)
+#define P16	(1 << 16)
+#define P17	(1 << 17)
+#define P18	(1 << 18)
+#define P19	(1 << 19)
+#define P20	(1 << 20)
+#define P21	(1 << 21)
+#define P22	(1 << 22)
+#define P23	(1 << 23)
+#define P24	(1 << 24)
+#define P25	(1 << 25)
+#define P26	(1 << 26)
+#define P27	(1 << 27)
+#define P28	(1 << 28)
+#define P29	(1 << 29)
+#define P30	(1 << 30)
+#define P31	(1 << 31)
+
+
+
+struct device_t
+{
+	char* name;
+	int TDO_PIO;	/* BANK holding TDO */
+	uint32_t TDO_PIN;
+	uint32_t TDO_MASK;	/* TDO bitmask */
+
+	int TRST_PIO;	/* BANK holding TRST */
+	uint32_t TRST_PIN;
+	uint32_t TRST_MASK;	/* TRST bitmask */
+
+	int TMS_PIO;	/* BANK holding TMS */
+	uint32_t TMS_PIN;
+	uint32_t TMS_MASK;	/* TMS bitmask */
+
+	int TCK_PIO;	/* BANK holding TCK */
+	uint32_t TCK_PIN;
+	uint32_t TCK_MASK;	/* TCK bitmask */
+
+	int TDI_PIO;	/* BANK holding TDI */
+	uint32_t TDI_PIN;
+	uint32_t TDI_MASK;	/* TDI bitmask */
+
+	int SRST_PIO;	/* BANK holding SRST */
+	uint32_t SRST_PIN;
+	uint32_t SRST_MASK;	/* SRST bitmask */
+
+	int BOOTSEL_PIO;	/* BANK holding BOOT0 */
+	uint32_t BOOTSEL_PIN;
+	uint32_t BOOTSEL_MASK;/* BOOT0 bitmask */
+};
+
+static struct device_t devices[] =
+{
+                     //TDO  TRST  TMS  TCK   TDI  SRST  BOOTSEL
+	{ "rea_ecr", PIO2 , 27, P27,
+                     PIO2,  28, P28,  
+                     PIO2,   5, P5, 
+                     PIO2,   1, P1, 
+                     PIO1,  28, P28, 
+                     PIO0,   6, P6 ,
+                     PIO0,  23, P23},
+	{ .name = NULL },
+};
+
+/* configuration */
+static char* imx233_device;
+
+/* interface variables
+ */
+static struct device_t* device;
+static int dev_mem_fd;
+static void *sys_controller;
+static uint32_t* pio_base;
+
+/* low level command set
+ */
+static int imx233_read(void);
+static void imx233_write(int tck, int tms, int tdi);
+static void imx233_reset(int trst, int srst);
+
+static int imx233_speed(int speed);
+static int imx233_init(void);
+static int imx233_quit(void);
+
+static struct bitbang_interface imx233_bitbang =
+{
+	.read = imx233_read,
+	.write = imx233_write,
+	.reset = imx233_reset,
+	.blink = 0
+};
+
+static int imx233_read(void)
+{
+	return (pio_base[(device->TDO_PIO + PIO_DIN)/sizeof(uint32_t)] & device->TDO_MASK);
+}
+
+static void imx233_write(int tck, int tms, int tdi)
+{
+	if (tck)
+		pio_base[(device->TCK_PIO + PIO_DOUT + SET)/sizeof(uint32_t)] = device->TCK_MASK;
+	else
+		pio_base[(device->TCK_PIO + PIO_DOUT + CLR)/sizeof(uint32_t)] = device->TCK_MASK;
+
+	if (tms)
+		pio_base[(device->TMS_PIO + PIO_DOUT + SET)/sizeof(uint32_t)] = device->TMS_MASK;
+	else
+		pio_base[(device->TMS_PIO + PIO_DOUT + CLR)/sizeof(uint32_t)] = device->TMS_MASK;
+
+	if (tdi)
+		pio_base[(device->TDI_PIO + PIO_DOUT + SET)/sizeof(uint32_t)] = device->TDI_MASK;
+	else
+		pio_base[(device->TDI_PIO + PIO_DOUT + CLR)/sizeof(uint32_t)] = device->TDI_MASK;
+}
+
+/* (1) assert or (0) deassert reset lines */
+static void imx233_reset(int trst, int srst)
+{
+
+	if (trst == 0)
+		pio_base[(device->TRST_PIO + PIO_DOUT + SET)/sizeof(uint32_t)] = device->TRST_MASK;
+	else if (trst == 1)
+		pio_base[(device->TRST_PIO + PIO_DOUT + CLR)/sizeof(uint32_t)] = device->TRST_MASK;
+
+	if (srst == 0)
+		pio_base[(device->SRST_PIO + PIO_DOUT + SET)/sizeof(uint32_t)] = device->SRST_MASK;
+	else if (srst == 1)
+		pio_base[(device->SRST_PIO + PIO_DOUT + CLR)/sizeof(uint32_t)] = device->SRST_MASK;
+
+}
+
+static int imx233_speed(int speed)
+{
+
+	return ERROR_OK;
+}
+
+COMMAND_HANDLER(imx233_handle_device_command)
+{
+	if (CMD_ARGC == 0)
+		return ERROR_OK;
+
+	/* only if the device name wasn't overwritten by cmdline */
+	if (imx233_device == 0)
+	{
+		imx233_device = malloc(strlen(CMD_ARGV[0]) + sizeof(char));
+		strcpy(imx233_device, CMD_ARGV[0]);
+	}
+
+	return ERROR_OK;
+}
+
+static const struct command_registration imx233_command_handlers[] = {
+	{
+		.name = "imx233_device",
+		.handler = &imx233_handle_device_command,
+		.mode = COMMAND_CONFIG,
+		.help = "query armjtagew info",
+	},
+	COMMAND_REGISTRATION_DONE
+};
+
+struct jtag_interface imx233_interface =
+{
+	.name = "imx233",
+
+	.execute_queue = bitbang_execute_queue,
+
+	.speed = imx233_speed,
+	.commands = imx233_command_handlers,
+	.init = imx233_init,
+	.quit = imx233_quit,
+};
+
+static int imx233_init(void)
+{
+	struct device_t *cur_device;
+
+	cur_device = devices;
+
+	if (imx233_device == NULL || imx233_device[0] == 0)
+	{
+		imx233_device = "rea_ecr";
+		LOG_WARNING("No imx233 device specified, using default 'rea_ecr'");
+	}
+
+	while (cur_device->name)
+	{
+		if (strcmp(cur_device->name, imx233_device) == 0)
+		{
+			device = cur_device;
+			break;
+		}
+		cur_device++;
+	}
+
+	if (!device)
+	{
+		LOG_ERROR("No matching device found for %s", imx233_device);
+		return ERROR_JTAG_INIT_FAILED;
+	}
+
+	bitbang_interface = &imx233_bitbang;
+
+	dev_mem_fd = open("/dev/mem", O_RDWR | O_SYNC);
+	if (dev_mem_fd < 0) {
+		perror("open");
+		return ERROR_JTAG_INIT_FAILED;
+	}
+
+	sys_controller = mmap(NULL, 4096, PROT_READ | PROT_WRITE,
+				MAP_SHARED, dev_mem_fd, IMX233_BASE_SYS);
+	if (sys_controller == MAP_FAILED) {
+		perror("mmap");
+		close(dev_mem_fd);
+		return ERROR_JTAG_INIT_FAILED;
+	}
+	pio_base = (uint32_t*)sys_controller;
+
+
+	/*
+	 * Configure TDO, TDI, TCK, TMS, TRST, SRST as GPIOs. 
+	 */
+
+	pio_base[(2*( device->TDI_PIO ) + PIO_MUXSEL + 16*(device->TDI_PIN/16)  + SET)/sizeof(uint32_t)] = (0x3 << 2*((device->TDI_PIN - 16)));
+	pio_base[(2*( device->TCK_PIO ) + PIO_MUXSEL + 16*(device->TCK_PIN/16)  + SET)/sizeof(uint32_t)] = (0x3 << 2*(device->TCK_PIN ));
+	pio_base[(2*( device->TMS_PIO ) + PIO_MUXSEL + 16*(device->TMS_PIN/16)  + SET)/sizeof(uint32_t)] = (0x3 << 2*(device->TMS_PIN ));
+	pio_base[(2*( device->TRST_PIO) + PIO_MUXSEL + 16*(device->TRST_PIN/16) + SET)/sizeof(uint32_t)] = (0x3 << 2*((device->TRST_PIN -16)));
+	pio_base[(2*( device->SRST_PIO) + PIO_MUXSEL + 16*(device->SRST_PIN/16) + SET)/sizeof(uint32_t)] = (0x3 << 2*(device->SRST_PIN));
+	pio_base[(2*( device->TDO_PIO ) + PIO_MUXSEL + 16*(device->TDO_PIN/16)  + SET)/sizeof(uint32_t)] = (0x3 << 2*((device->TDO_PIN - 16)));
+
+
+	/*
+	 * Configure TDO as an input; TDI, TCK, TMS, TRST, SRST as outputs. 
+	 */
+
+	pio_base[(device->TDI_PIO  + PIO_DOE + SET)/sizeof(uint32_t)] = device->TDI_MASK;   // Set as OUTPUT
+	pio_base[(device->TCK_PIO  + PIO_DOE + SET)/sizeof(uint32_t)] = device->TCK_MASK;   // Set as OUTPUT
+	pio_base[(device->TMS_PIO  + PIO_DOE + SET)/sizeof(uint32_t)] = device->TMS_MASK;   // Set as OUTPUT
+	pio_base[(device->TRST_PIO + PIO_DOE + SET)/sizeof(uint32_t)] = device->TRST_MASK;  // Set as OUTPUT
+	pio_base[(device->SRST_PIO + PIO_DOE + SET)/sizeof(uint32_t)] = device->SRST_MASK;  // Set as OUTPUT
+	pio_base[(device->TDO_PIO  + PIO_DOE + CLR)/sizeof(uint32_t)] = device->TDO_MASK;   // Set as INPUT
+
+	/* Drive TDI and TCK low, and TMS/TRST/SRST high. */
+
+	pio_base[(device->TDI_PIO  + PIO_DOUT + CLR)/sizeof(uint32_t)] = device->TDI_MASK;
+	pio_base[(device->TCK_PIO  + PIO_DOUT + CLR)/sizeof(uint32_t)] = device->TCK_MASK;
+
+	pio_base[(device->TMS_PIO  + PIO_DOUT + SET)/sizeof(uint32_t)] = device->TMS_MASK;
+	pio_base[(device->TRST_PIO + PIO_DOUT + SET)/sizeof(uint32_t)] = device->TRST_MASK;
+	pio_base[(device->SRST_PIO + PIO_DOUT + SET)/sizeof(uint32_t)] = device->SRST_MASK;
+
+
+	return ERROR_OK;
+}
+
+static int imx233_quit(void)
+{
+
+	return ERROR_OK;
+}
diff -Naur openocd-0.7.0/src/jtag/drivers/imx233_mini.c openocd-0.7.0_stamp/src/jtag/drivers/imx233_mini.c
--- openocd-0.7.0/src/jtag/drivers/imx233_mini.c	1970-01-01 00:00:00.000000000 +0000
+++ openocd-0.7.0_stamp/src/jtag/drivers/imx233_mini.c	2013-05-17 03:07:12.000000000 +0000
@@ -0,0 +1,322 @@
+/***************************************************************************
+ *   Copyright (C) 2006 by Anders Larsen                                   *
+ *   al@alarsen.net                                                        *
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ *   This program is distributed in the hope that it will be useful,       *
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
+ *   GNU General Public License for more details.                          *
+ *                                                                         *
+ *   You should have received a copy of the GNU General Public License     *
+ *   along with this program; if not, write to the                         *
+ *   Free Software Foundation, Inc.,                                       *
+ *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
+ ***************************************************************************/
+#ifdef HAVE_CONFIG_H
+#include "config.h"
+#endif
+
+#include <jtag/interface.h>
+#include "bitbang.h"
+
+#include <sys/mman.h>
+
+
+/* AT91RM9200 */
+#define IMX233_BASE_SYS	(0x80018000)
+
+/* GPIO assignment (MUX_REG)*/
+
+
+#define PIO_CTRL	(0)		/* PIO enable */
+#define PIO_MUXSEL	(0x100)		/* output enable */
+#define PIO_DRIVE	(0x200)		/* output disable */
+#define PIO_PULL	(0x400)		/* set output data */
+#define PIO_DOUT	(0x500)		/* clear output data */
+#define PIO_DIN 	(0x600)		/* pin data status */
+#define PIO_DOE 	(0x700)		/* pull-up enable */
+#define PIO_PIN2IRQ 	(0x800)		/* pull-up enable */
+#define PIO_IRQEN 	(0x900)		/* pull-up enable */
+#define PIO_IRLEV 	(0xa00)		/* pull-up enable */
+#define PIO_POL 	(0xb00)		/* pull-up enable */
+#define PIO_IRQSTAT 	(0xc00)		/* pull-up enable */
+
+#define SET             (0x4)
+#define CLR             (0x8)
+#define TOG             (0xC)
+
+
+#define PIO0	(0*4)  //0x00
+#define PIO1	(4*4)  //0x10
+#define PIO2	(8*4)  //0x20
+#define PIO3	(12*4) //0x30
+
+
+
+#define NC	(0)			/* not connected */
+#define P0	(1 << 0)
+#define P1	(1 << 1)
+#define P2	(1 << 2)
+#define P3	(1 << 3)
+#define P4	(1 << 4)
+#define P5	(1 << 5)
+#define P6	(1 << 6)
+#define P7	(1 << 7)
+#define P8	(1 << 8)
+#define P9	(1 << 9)
+#define P10	(1 << 10)
+#define P11	(1 << 11)
+#define P12	(1 << 12)
+#define P13	(1 << 13)
+#define P14	(1 << 14)
+#define P15	(1 << 15)
+#define P16	(1 << 16)
+#define P17	(1 << 17)
+#define P18	(1 << 18)
+#define P19	(1 << 19)
+#define P20	(1 << 20)
+#define P21	(1 << 21)
+#define P22	(1 << 22)
+#define P23	(1 << 23)
+
+#define P24	(1 << 24)
+#define P25	(1 << 25)
+#define P26	(1 << 26)
+#define P27	(1 << 27)
+#define P28	(1 << 28)
+#define P29	(1 << 29)
+#define P30	(1 << 30)
+#define P31	(1 << 31)
+
+
+
+struct device_t
+{
+	char* name;
+
+	int      TRST_PIO;	/* BANK holding TRST */
+	uint32_t TRST_PIN;
+	uint32_t TRST_MASK;	/* TRST bitmask */
+
+	int      TDO_PIO;	/* BANK holding TDO */
+	uint32_t TDO_PIN;
+	uint32_t TDO_MASK;	/* TDO bitmask */
+
+	int      TDI_PIO;	/* BANK holding TDI */
+	uint32_t TDI_PIN;
+	uint32_t TDI_MASK;	/* TDI bitmask */
+
+	int      TCK_PIO;	/* BANK holding TCK */
+	uint32_t TCK_PIN;
+	uint32_t TCK_MASK;	/* TCK bitmask */
+
+	int      TMS_PIO;	/* BANK holding TMS */
+	uint32_t TMS_PIN;
+	uint32_t TMS_MASK;	/* TMS bitmask */
+};
+
+static struct device_t devices[] =
+{
+                     //NRST  TDO  TDI TCK TMS  
+	{ "rea_ecr", PIO0 , 6, P6,
+                     PIO0,  4, P4,  
+                     PIO0, 25, P25, 
+                     PIO0, 16, P16, 
+                     PIO0, 17, P17},
+	{ .name = NULL },
+};
+
+/* configuration */
+static char* imx233_device;
+
+/* interface variables
+ */
+static struct device_t* device;
+static int dev_mem_fd;
+static void *sys_controller;
+static uint32_t* pio_base;
+
+/* low level command set
+ */
+static int imx233_read(void);
+static void imx233_write(int tck, int tms, int tdi);
+static void imx233_reset(int trst, int srst);
+
+static int imx233_speed(int speed);
+static int imx233_init(void);
+static int imx233_quit(void);
+
+static struct bitbang_interface imx233_bitbang =
+{
+	.read = imx233_read,
+	.write = imx233_write,
+	.reset = imx233_reset,
+	.blink = 0
+};
+
+static int imx233_read(void)
+{
+	return (pio_base[(device->TDO_PIO + PIO_DIN)/sizeof(uint32_t)] & device->TDO_MASK);
+}
+
+static void imx233_write(int tck, int tms, int tdi)
+{
+	if (tck)
+		pio_base[(device->TCK_PIO + PIO_DOUT + SET)/sizeof(uint32_t)] = device->TCK_MASK;
+	else
+		pio_base[(device->TCK_PIO + PIO_DOUT + CLR)/sizeof(uint32_t)] = device->TCK_MASK;
+
+	if (tms)
+		pio_base[(device->TMS_PIO + PIO_DOUT + SET)/sizeof(uint32_t)] = device->TMS_MASK;
+	else
+		pio_base[(device->TMS_PIO + PIO_DOUT + CLR)/sizeof(uint32_t)] = device->TMS_MASK;
+
+	if (tdi)
+		pio_base[(device->TDI_PIO + PIO_DOUT + SET)/sizeof(uint32_t)] = device->TDI_MASK;
+	else
+		pio_base[(device->TDI_PIO + PIO_DOUT + CLR)/sizeof(uint32_t)] = device->TDI_MASK;
+}
+
+/* (1) assert or (0) deassert reset lines */
+static void imx233_reset(int trst, int srst)
+{
+
+	if (trst == 0)
+		pio_base[(device->TRST_PIO + PIO_DOUT + SET)/sizeof(uint32_t)] = device->TRST_MASK;
+	else if (trst == 1)
+		pio_base[(device->TRST_PIO + PIO_DOUT + CLR)/sizeof(uint32_t)] = device->TRST_MASK;
+
+}
+
+static int imx233_speed(int speed)
+{
+
+	return ERROR_OK;
+}
+
+COMMAND_HANDLER(imx233_handle_device_command)
+{
+	if (CMD_ARGC == 0)
+		return ERROR_OK;
+
+	/* only if the device name wasn't overwritten by cmdline */
+	if (imx233_device == 0)
+	{
+		imx233_device = malloc(strlen(CMD_ARGV[0]) + sizeof(char));
+		strcpy(imx233_device, CMD_ARGV[0]);
+	}
+
+	return ERROR_OK;
+}
+
+static const struct command_registration imx233_command_handlers[] = {
+	{
+		.name = "imx233_device",
+		.handler = &imx233_handle_device_command,
+		.mode = COMMAND_CONFIG,
+		.help = "query armjtagew info",
+	},
+	COMMAND_REGISTRATION_DONE
+};
+
+struct jtag_interface imx233_mini_interface =
+{
+	.name = "imx233_mini",
+
+	.execute_queue = bitbang_execute_queue,
+
+	.speed = imx233_speed,
+	.commands = imx233_command_handlers,
+	.init = imx233_init,
+	.quit = imx233_quit,
+};
+
+static int imx233_init(void)
+{
+	struct device_t *cur_device;
+
+	cur_device = devices;
+
+	if (imx233_device == NULL || imx233_device[0] == 0)
+	{
+		imx233_device = "rea_ecr";
+		LOG_WARNING("No imx233 device specified, using default 'rea_ecr'");
+	}
+
+	while (cur_device->name)
+	{
+		if (strcmp(cur_device->name, imx233_device) == 0)
+		{
+			device = cur_device;
+			break;
+		}
+		cur_device++;
+	}
+
+	if (!device)
+	{
+		LOG_ERROR("No matching device found for %s", imx233_device);
+		return ERROR_JTAG_INIT_FAILED;
+	}
+
+	bitbang_interface = &imx233_bitbang;
+
+	dev_mem_fd = open("/dev/mem", O_RDWR | O_SYNC);
+	if (dev_mem_fd < 0) {
+		perror("open");
+		return ERROR_JTAG_INIT_FAILED;
+	}
+
+	sys_controller = mmap(NULL, 4096, PROT_READ | PROT_WRITE,
+				MAP_SHARED, dev_mem_fd, IMX233_BASE_SYS);
+	if (sys_controller == MAP_FAILED) {
+		perror("mmap");
+		close(dev_mem_fd);
+		return ERROR_JTAG_INIT_FAILED;
+	}
+	pio_base = (uint32_t*)sys_controller;
+
+
+	/*
+	 * Configure TDO, TDI, TCK, TMS, TRST as GPIOs. 
+	 */
+
+	pio_base[(2*( device->TRST_PIO) + PIO_MUXSEL + 16*(device->TRST_PIN/16) + SET)/sizeof(uint32_t)] = (0x3 << 2*(device->TRST_PIN));
+	pio_base[(2*( device->TDO_PIO ) + PIO_MUXSEL + 16*(device->TDO_PIN/16)  + SET)/sizeof(uint32_t)] = (0x3 << 2*(device->TDO_PIN ));
+	pio_base[(2*( device->TDI_PIO ) + PIO_MUXSEL + 16*(device->TDI_PIN/16)  + SET)/sizeof(uint32_t)] = (0x3 << 2*((device->TDI_PIN - 16)));
+	pio_base[(2*( device->TCK_PIO ) + PIO_MUXSEL + 16*(device->TCK_PIN/16)  + SET)/sizeof(uint32_t)] = (0x3 << 2*((device->TCK_PIN - 16)));
+	pio_base[(2*( device->TMS_PIO ) + PIO_MUXSEL + 16*(device->TMS_PIN/16)  + SET)/sizeof(uint32_t)] = (0x3 << 2*((device->TMS_PIN - 16)));
+
+
+	/*
+	 * Configure TDO as an input; TDI, TCK, TMS, TRST, SRST as outputs. 
+	 */
+
+	pio_base[(device->TDI_PIO  + PIO_DOE + SET)/sizeof(uint32_t)] = device->TDI_MASK;   // Set as OUTPUT
+	pio_base[(device->TCK_PIO  + PIO_DOE + SET)/sizeof(uint32_t)] = device->TCK_MASK;   // Set as OUTPUT
+	pio_base[(device->TMS_PIO  + PIO_DOE + SET)/sizeof(uint32_t)] = device->TMS_MASK;   // Set as OUTPUT
+	pio_base[(device->TRST_PIO + PIO_DOE + SET)/sizeof(uint32_t)] = device->TRST_MASK;  // Set as OUTPUT
+	pio_base[(device->TDO_PIO  + PIO_DOE + CLR)/sizeof(uint32_t)] = device->TDO_MASK;   // Set as INPUT
+
+	/* Drive TDI and TCK low, and TMS/TRST/SRST high. */
+
+	pio_base[(device->TDI_PIO  + PIO_DOUT + CLR)/sizeof(uint32_t)] = device->TDI_MASK;
+	pio_base[(device->TCK_PIO  + PIO_DOUT + CLR)/sizeof(uint32_t)] = device->TCK_MASK;
+
+	pio_base[(device->TMS_PIO  + PIO_DOUT + SET)/sizeof(uint32_t)] = device->TMS_MASK;
+	pio_base[(device->TRST_PIO + PIO_DOUT + SET)/sizeof(uint32_t)] = device->TRST_MASK;
+
+
+	return ERROR_OK;
+}
+
+static int imx233_quit(void)
+{
+
+	return ERROR_OK;
+}
diff -Naur openocd-0.7.0/src/jtag/interfaces.c openocd-0.7.0_stamp/src/jtag/interfaces.c
--- openocd-0.7.0/src/jtag/interfaces.c	2013-04-19 21:54:16.000000000 +0000
+++ openocd-0.7.0_stamp/src/jtag/interfaces.c	2013-05-17 02:14:17.000000000 +0000
@@ -74,6 +74,12 @@
 #if BUILD_AT91RM9200 == 1
 extern struct jtag_interface at91rm9200_interface;
 #endif
+#if BUILD_IMX233 == 1
+extern struct jtag_interface imx233_interface;
+#endif
+#if BUILD_IMX233_MINI == 1
+extern struct jtag_interface imx233_mini_interface;
+#endif
 #if BUILD_GW16012 == 1
 extern struct jtag_interface gw16012_interface;
 #endif
@@ -158,6 +164,12 @@
 #if BUILD_AT91RM9200 == 1
 		&at91rm9200_interface,
 #endif
+#if BUILD_IMX233 == 1
+		&imx233_interface,
+#endif
+#if BUILD_IMX233_MINI == 1
+		&imx233_mini_interface,
+#endif
 #if BUILD_GW16012 == 1
 		&gw16012_interface,
 #endif
diff -Naur openocd-0.7.0/src/target/cortex_a.c openocd-0.7.0_stamp/src/target/cortex_a.c
--- openocd-0.7.0/src/target/cortex_a.c	2013-04-28 10:36:03.000000000 +0000
+++ openocd-0.7.0_stamp/src/target/cortex_a.c	2013-05-23 11:58:11.849999972 +0000
@@ -2059,8 +2059,10 @@
 	}
 
 	/* Read the last word */
+        uint32_t tmp;
 	retval = mem_ap_sel_read_atomic_u32(swjdp, armv7a->debug_ap,
-				armv7a->debug_base + CPUDBG_DTRTX, (uint32_t *)&tmp_buff[(total_u32-1)<<2]);
+				armv7a->debug_base + CPUDBG_DTRTX, &tmp);
+        buf_set_u32(&tmp_buff[(total_u32-1)<<2], 0, 32, tmp);
 	if (retval != ERROR_OK)
 		goto error_free_buff_r;
 
